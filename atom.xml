<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Keep2iron&#39;s Road to development</title>
  
  <subtitle>Keep2iron&#39;s Road to development</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://keep2iron.github.io/"/>
  <updated>2018-08-21T16:39:24.075Z</updated>
  <id>https://keep2iron.github.io/</id>
  
  <author>
    <name>Keep2iron</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>大话自定义view(1)</title>
    <link href="https://keep2iron.github.io/2018/08/19/%E5%A4%A7%E8%AF%9D%E8%87%AA%E5%AE%9A%E4%B9%89view(%E4%B8%80)/"/>
    <id>https://keep2iron.github.io/2018/08/19/大话自定义view(一)/</id>
    <published>2018-08-19T12:33:00.000Z</published>
    <updated>2018-08-21T16:39:24.075Z</updated>
    
    <content type="html"><![CDATA[<h5>出师不利</h5><p>小艾从新兵训练营毕业，在训练营中学习不少编程方面的知识，学着编写了不少Android方面的小程序，他踌躇满志一心想要报考<em>Android调查兵团</em>。终于当投递了无数次申请了之后，调查兵团准许了小艾的申请，并给与了他一次面试的机会。</p><p>到了要进行面试的日子，考官发放了一个题目，上面写道：“<strong>请编写一个如下图的自定义控件</strong>”</p><p><img src="https://i.imgur.com/X1ZyPpl.png" alt="pic1"></p><a id="more"></a><p>小艾心想糟了，身上这一身本事都是CV老师教的(PS:老夫敲代码就是一梭子.png)，自己写这自定义控件还真的是不太行阿~。小艾心灰意冷的答完了题目，垂头丧一些气的回到了自己的房间，痛定思痛心想：这自定义控件劳资一定要攻破它，说着小艾就打开了aoogle搜索了一下这自定义控件的一些知识。</p><p></p><h5>奇怪的Constructor</h5>小艾：哦，这第一步原来是要继承一个View或者一个ViewGroup​，我这个自定义控件是一个圆形进度条，那么我就起名叫<strong>CircleProgressView</strong>吧！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CircleProgress</span> <span class="keyword">extends</span> <span class="title">View</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">CircleProgress</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>(context, <span class="keyword">null</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//@Nullable是android扩展包的注解，标识这个变量是可以为null的</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">CircleProgress</span><span class="params">(Context context, @Nullable AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>(context, attrs, <span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">CircleProgress</span><span class="params">(Context context, @Nullable AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>可是这自定义View为啥要重写了这三个方法呢？小艾这是产生了一个疑惑，不过正好今天是一个星期六，大表哥正好来小艾家玩，心里正犯嘀咕。大表哥看了一眼代码，瞅了一眼犯嘀咕的小艾。</p><p>大表哥：”小艾呀，我知道你心中为啥这么困惑。首先第一个方法<em>CircleProgress(Context)</em>是保证了我们能够<strong>直接创建一个自定义控件</strong>因此才有了第一个构造方法。第二个方法的带了一个<strong>AttributeSet</strong>，这个方法是为了Android中使用<strong>Pull解析</strong>xml时，解析之后的属性便全部都放入了这个对象中，简单点说就是为了<strong>提供给xml解析时调用</strong>。第三个方法嘛，说来安卓真的是为我们开发者操碎了心，第三个参数用于解析主题文件时能够产生不同属性值，因此才有了这第三个参数。”</p><blockquote><p>在第一种new出来的生成方式的时候，会调用一个参数的构造方法。</p></blockquote><blockquote><p>第二种使用xml声明的方式则会调用两个参数的构造方法</p></blockquote><blockquote><p>第三个参数的意义在于在当前主题中包含了style资源的一个属性值，适用于对于当前view的一个默认style。 需要特别指出的是三个参数的构造方法系统是不进行调用的，需要我们这里显式的进行调用，比如我们的Button通过调用，并传递了com.android.internal.R.attr.buttonStyle，而在4.4的主题文件是holo风格，然后定义了button的默认的几个属性</p></blockquote><p>以Button为例下面，是Button的构造方法以及style文件中的声明。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Button</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>(context, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Button</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>(context, attrs, com.android.internal.R.attr.buttonStyle);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Button</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyle)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(context, attrs, defStyle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"Theme.DeviceDefault"</span> <span class="attr">parent</span>=<span class="string">"Theme.Holo"</span> &gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">...</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"buttonStyle"</span>&gt;</span>@android:style/Widget.DeviceDefault.Button<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="undefined">....</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"Widget.DeviceDefault.Button"</span> <span class="attr">parent</span>=<span class="string">"Widget.Holo.Button"</span> &gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"Widget.Holo.Button"</span> <span class="attr">parent</span>=<span class="string">"Widget.Button"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:background"</span>&gt;</span>@android:drawable/btn_default_holo_dark<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:textAppearance"</span>&gt;</span>?android:attr/textAppearanceMedium<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:textColor"</span>&gt;</span>@android:color/primary_text_holo_dark<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:minHeight"</span>&gt;</span>48dip<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:minWidth"</span>&gt;</span>64dip<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><h5>懵逼的onMeasure</h5>大表哥：言归正传，以上就是构造函数的一些意义啦，这些东西多结合实战才会有进步~！当然了理解constructor的过程还是第一步，后面还有你好看的呢~！来看一下这个函数。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line"><span class="comment">//获取测量的宽度和高度</span></span><br><span class="line"><span class="keyword">int</span> widthSize = getMeasureSize(widthMeasureSpec);</span><br><span class="line"><span class="keyword">int</span> heightSize = getMeasureSize(heightMeasureSpec);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> size = widthSize &gt; heightSize ? heightSize : widthSize;</span><br><span class="line"><span class="comment">//必须调用这个方法，进行设置大小</span></span><br><span class="line">setMeasuredDimension(size,size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getMeasureSize</span><span class="params">(<span class="keyword">int</span> measureSpec)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> mode = MeasureSpec.getMode(measureSpec);</span><br><span class="line"><span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span>(mode)&#123;</span><br><span class="line"><span class="keyword">case</span> MeasureSpec.EXACTLY:</span><br><span class="line"><span class="keyword">case</span> MeasureSpec.AT_MOST:</span><br><span class="line">size = MeasureSpec.getSize(measureSpec);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</span><br><span class="line">size = CommonUtil.dp2px(getContext(),<span class="number">50</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//决定了我们自己的控件相对与父控件的位置</span></span><br><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.onLayout(changed, left, top, right, bottom);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>小艾：哇，这个函数干啥玩意的咋越看越懵逼呢！！<br>大表哥：哈哈，懵逼吧~，不过我先跟你阐述几个概念，这几个概念你心里有个数，后面不会再查文档就行了。</p><p><strong>EXACTLY</strong></p><p>表示父视图希望子视图的大小应该是由specSize的值来决定的，系统默认会按照这个规则来设置子视图的大小，开发人员当然也可以按照自己的意愿设置成任意的大小。</p><p><strong>AT_MOST</strong></p><p>表示子视图最多只能是specSize中指定的大小，开发人员应该尽可能小得去设置这个视图，并且保证不会超过specSize。系统默认会按照这个规则来设置子视图的大小，开发人员当然也可以按照自己的意愿设置成任意的大小。</p><p><strong>UNSPECIFIED</strong></p><p>表示开发人员可以将视图按照自己的意愿设置成任意的大小，没有任何限制。这种情况比较少见，不太会用到。</p><blockquote><p>上面的一些表述参考了郭霖的<a href="http://blog.csdn.net/guolin_blog/article/details/16330267" target="_blank" rel="noopener">博客</a></p></blockquote><p></p><h5>一些基本的操作</h5><br>大表哥：今天主要是画这个进度是吧，既然要画东西（Canvas），起码我们是必须要有一个笔的，在Android中有个类叫<strong>Paint</strong>，你去官方文档看下它这个相关的api做一些demo基本上就能够上手啦~！当然我们这里再来说说获取了画笔之后，一些关于自定义控件的基本操作。有几点是要确定的<br><strong>1.绘制区域的大小（主要跟控件的大小有关）</strong><br>小艾：立方懵逼.png…….<br>大表哥：一般我觉得写自定义控件来说，获取他的大小基本上必不可少，那么在什么函数获取大小比较合适呢？我个人认为在onSizeChanged(int w, int h, int oldw, int oldh) 这个方法中进行赋值大小比较合适。虽然onDraw可以获取但是onDraw会可能会调用多次，书写一些初始化操作就不太合适了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onSizeChanged</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">int</span> oldw, <span class="keyword">int</span> oldh)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.onSizeChanged(w, h, oldw, oldh);</span><br><span class="line"><span class="comment">//初始化画笔的宽度</span></span><br><span class="line"><span class="keyword">int</span> strokeSize = (<span class="keyword">int</span>) (getMeasuredWidth() / <span class="number">2</span> * <span class="number">0.3f</span>);</span><br><span class="line"><span class="keyword">int</span> size = <span class="number">10</span> + strokeSize;</span><br><span class="line"><span class="comment">//初始化绘制区域</span></span><br><span class="line">mDrawRect = <span class="keyword">new</span> RectF(getPaddingLeft() + size,getPaddingTop() + size,getWidth() -getPaddingLeft() - size,getHeight() - getPaddingBottom() - size);</span><br><span class="line">mPaint.setStrokeWidth(strokeSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p></p><h5>干活啦！气氛搞起来~</h5><br>大表哥：终于到了你应该最感兴趣的代码了，这里来说说绘制的流程<p></p><ol><li><p><strong>canvas.save()</strong>这里主要为了保存画布的状态，因为后面可能还需要针对画布进行旋转、平移、缩放等等操作。</p></li><li><p><strong>canvas.ratate/translate/scale</strong>这里是针对画布进行平移缩放，当然了画布的坐标系也会同步修改。</p></li><li><strong>canvas.draw</strong>这里就是干活的地方，发挥你灵魂画师的基本功力，在这里可以为所欲为的画你想画的东西。</li><li><strong>canvas.restore()</strong>切记如果你之前<strong>save过画布之后，一定要restore！！</strong>,你也不想后面画着其他图形的时候犯嘀咕，咦？我这矩形咋飞上了天？？明明就是居中的阿~~。<strong>主要就是恢复save时canvas的坐标系</strong>。</li></ol><p>下面就是一个代码实例，小艾你就跟着多练习啦，下午有个大保健等着我，溜了溜了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line"><span class="comment">//保存画布的当前状态</span></span><br><span class="line">canvas.save();</span><br><span class="line"><span class="comment">//旋转画布逆时针90°，那么坐标系就发生了旋转了。</span></span><br><span class="line">canvas.rotate(-<span class="number">90</span>,mDrawRect.centerX(),mDrawRect.centerY());</span><br><span class="line"><span class="comment">//设置背景圆的颜色</span></span><br><span class="line">mPaint.setColor(mDefColor);</span><br><span class="line">canvas.drawCircle(mDrawRect.centerX(),mDrawRect.centerY(),mDrawRect.width() / <span class="number">2</span>,mPaint);</span><br><span class="line"><span class="comment">//设置弧线的颜色</span></span><br><span class="line">mPaint.setColor(mColor);</span><br><span class="line">canvas.drawArc(mDrawRect,<span class="number">0</span>,mProgress * <span class="number">360</span>,<span class="keyword">false</span>,mPaint);</span><br><span class="line"><span class="comment">//重新恢复画布</span></span><br><span class="line">canvas.restore();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>小艾：留下了没技术的泪水.png~~~</p><p>自定义控件系列还在持续连载中!!!!coming soon</p>]]></content>
    
    <summary type="html">
    
      &lt;h5&gt;出师不利&lt;/h5&gt;

&lt;p&gt;小艾从新兵训练营毕业，在训练营中学习不少编程方面的知识，学着编写了不少Android方面的小程序，他踌躇满志一心想要报考&lt;em&gt;Android调查兵团&lt;/em&gt;。终于当投递了无数次申请了之后，调查兵团准许了小艾的申请，并给与了他一次面试的机会。&lt;/p&gt;
&lt;p&gt;到了要进行面试的日子，考官发放了一个题目，上面写道：“&lt;strong&gt;请编写一个如下图的自定义控件&lt;/strong&gt;”&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/X1ZyPpl.png&quot; alt=&quot;pic1&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="https://keep2iron.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>React Native vs Native</title>
    <link href="https://keep2iron.github.io/2018/08/19/ReactNative/"/>
    <id>https://keep2iron.github.io/2018/08/19/ReactNative/</id>
    <published>2018-08-19T07:46:34.000Z</published>
    <updated>2018-08-21T16:41:51.700Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/wdMolXp.png" width="680px"></p><h1 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h1><ul><li><p><strong>某些方面上开发效率高</strong> 在某些方面React Native开发效率比原生效率高，这里指的是开发效率，因为HotReload的关系，因此在开发React Native的时候基本上不用重新编译整个工程，这一点我认为对开发者的开发体验来说是非常棒的，在这里我指的是某些方面，当然什么方面来说的话后面会详细的进行展开。</p></li><li><p><strong>复杂的布局也能得心应手。</strong> Flex布局针对于复杂页面的布局很有优势，由于之前是做安卓开发，比如安卓在开发流式布局或者自定义多样化的布局上需要进行<strong>自定义View</strong>，如果考虑性能可能还需要进行使用RecyclerView进行多布局。因此结合css position属性 + flex可以轻松应对大多数场景了。</p></li><li><p><strong>开发效率快。</strong> 由于js是弱类型语言，在ReactNative中使用了基于es6的语法，因此可以大大提高了js面向对象的编程的能力。而且语法糖丰富，第三方扩展多，使用npm基本上什么库都能够找到你想要的第三方库</p></li><li><p><strong>learn once write everywhere!!</strong> 这里的优势确实还是有的，由于之前确实学习过一段时间的React，对于React的这套体系(更改State驱动界面更新，Props可以用来跨组件传值等等)这些在React编程的思路确实是没有变化的，因此前端对于转来学习React Native应该是问题不大的。</p></li><li><p><strong>跨平台</strong> 这一点恐怕是选择React Native的一个非常重要的原因。</p></li></ul><h1 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h1><ul><li><p><strong>React Native更新太快</strong> 通常我们说软件更新快是一件好事情，但是对于咱们开发React Native来说的话确实有点….(学不动.png)，更新太快会有一些库的兼容问题，因此很可能半年之前写的项目不能很好的运行在最新的React Native的版本之上。（相信React Native后面能够稳定下来）</p></li><li><p><strong>第三方库的质量问题</strong> 本着不重复造轮子的原则，我们一般都会或多或少的引入第三方库。对于React Native来说的话确实优秀的第三方库太少了，一般很难满足自己的需求，因此只能读其代码进行定制化的改造。这一点也确实是由于精通Android 和ios以及Rn的开发者比较少，很少能够进行全面的编写完美的跨平台组件。（基于稳定下来之后，我想这个问题也能够得到充分的解决）</p></li><li><p><strong>React Native稀奇古怪的问题还是不少</strong> 这一点上主要在于刚刚接触React Native的时候对于语法以及开发项目的不理解时导致的问题挺多的。（没办法只能说坑踩的多了，你就是大佬了）</p></li><li><p><strong>成也js败也js</strong> 这一点只能代表我个人观点，js的动态能力很强，在代码的编写上可以说是每一个人都有心中自己的最佳实践。（当然了客观上我们还是需要多学习像airbnb等这些大公司编写的优秀的代码）在js中，当我们要调用别人的库的时候我们只能够进行查找文档或者找到对应的博客进行学习。对于我这种从java转过来的编程者更倾向于希望阅读代码的api注释以及传入参数的限制等等，这样的话对于开发效率的提升也是不小的，而且可以更快的上手。（不过对于js这种动态类型来说，TypeScript（它不是一个库，应该说是js的另外一种生态了）、Flow这种可以帮助js进行类型检查的库或者生态能够更好的解决这个问题了）</p></li></ul><a id="more"></a><h5>原有Android项目集成ReactNative</h5><p>自定义跳转规则</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.imgur.com/wdMolXp.png&quot; width=&quot;680px&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;优势&quot;&gt;&lt;a href=&quot;#优势&quot; class=&quot;headerlink&quot; title=&quot;优势&quot;&gt;&lt;/a&gt;优势&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;某些方面上开发效率高&lt;/strong&gt; 在某些方面React Native开发效率比原生效率高，这里指的是开发效率，因为HotReload的关系，因此在开发React Native的时候基本上不用重新编译整个工程，这一点我认为对开发者的开发体验来说是非常棒的，在这里我指的是某些方面，当然什么方面来说的话后面会详细的进行展开。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;复杂的布局也能得心应手。&lt;/strong&gt; Flex布局针对于复杂页面的布局很有优势，由于之前是做安卓开发，比如安卓在开发流式布局或者自定义多样化的布局上需要进行&lt;strong&gt;自定义View&lt;/strong&gt;，如果考虑性能可能还需要进行使用RecyclerView进行多布局。因此结合css position属性 + flex可以轻松应对大多数场景了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;开发效率快。&lt;/strong&gt; 由于js是弱类型语言，在ReactNative中使用了基于es6的语法，因此可以大大提高了js面向对象的编程的能力。而且语法糖丰富，第三方扩展多，使用npm基本上什么库都能够找到你想要的第三方库&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;learn once write everywhere!!&lt;/strong&gt; 这里的优势确实还是有的，由于之前确实学习过一段时间的React，对于React的这套体系(更改State驱动界面更新，Props可以用来跨组件传值等等)这些在React编程的思路确实是没有变化的，因此前端对于转来学习React Native应该是问题不大的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;跨平台&lt;/strong&gt; 这一点恐怕是选择React Native的一个非常重要的原因。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;不足&quot;&gt;&lt;a href=&quot;#不足&quot; class=&quot;headerlink&quot; title=&quot;不足&quot;&gt;&lt;/a&gt;不足&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;React Native更新太快&lt;/strong&gt; 通常我们说软件更新快是一件好事情，但是对于咱们开发React Native来说的话确实有点….(学不动.png)，更新太快会有一些库的兼容问题，因此很可能半年之前写的项目不能很好的运行在最新的React Native的版本之上。（相信React Native后面能够稳定下来）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;第三方库的质量问题&lt;/strong&gt; 本着不重复造轮子的原则，我们一般都会或多或少的引入第三方库。对于React Native来说的话确实优秀的第三方库太少了，一般很难满足自己的需求，因此只能读其代码进行定制化的改造。这一点也确实是由于精通Android 和ios以及Rn的开发者比较少，很少能够进行全面的编写完美的跨平台组件。（基于稳定下来之后，我想这个问题也能够得到充分的解决）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;React Native稀奇古怪的问题还是不少&lt;/strong&gt; 这一点上主要在于刚刚接触React Native的时候对于语法以及开发项目的不理解时导致的问题挺多的。（没办法只能说坑踩的多了，你就是大佬了）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;成也js败也js&lt;/strong&gt; 这一点只能代表我个人观点，js的动态能力很强，在代码的编写上可以说是每一个人都有心中自己的最佳实践。（当然了客观上我们还是需要多学习像airbnb等这些大公司编写的优秀的代码）在js中，当我们要调用别人的库的时候我们只能够进行查找文档或者找到对应的博客进行学习。对于我这种从java转过来的编程者更倾向于希望阅读代码的api注释以及传入参数的限制等等，这样的话对于开发效率的提升也是不小的，而且可以更快的上手。（不过对于js这种动态类型来说，TypeScript（它不是一个库，应该说是js的另外一种生态了）、Flow这种可以帮助js进行类型检查的库或者生态能够更好的解决这个问题了）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Simple Record" scheme="https://keep2iron.github.io/tags/Simple-Record/"/>
    
  </entry>
  
  <entry>
    <title>okhttp源码解析</title>
    <link href="https://keep2iron.github.io/2018/04/29/okhttp%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://keep2iron.github.io/2018/04/29/okhttp源码解析/</id>
    <published>2018-04-29T02:41:03.000Z</published>
    <updated>2018-08-19T08:02:48.941Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/pmIxXFe.png" alt=""></p><p>安卓开发领域上<a href="https://github.com/square/okhttp" target="_blank" rel="noopener">Okhttp</a>、<a href="https://github.com/square/retrofit" target="_blank" rel="noopener">Retrofit</a>、<a href="https://github.com/ReactiveX/RxJava" target="_blank" rel="noopener">RxJava</a>无疑已经成为了开发过程中的三板斧。在安卓6.0中谷歌删除了HttpClient的相关代码，并且在系统层面上使用了OkHttp，因此足以说明了这个框架的优秀。</p><p><a href="https://github.com/android-cn/android-open-project-analysis" target="_blank" rel="noopener">我们不重复造轮子不表示我们不需要知道轮子该怎么造及如何更好的造!</a> </p><a id="more"></a><p>用了OkHttp已经一年多之后，现在是时候来一探究竟了!!</p><h2 id="整体思路"><a href="#整体思路" class="headerlink" title="整体思路"></a>整体思路</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.imgur.com/pmIxXFe.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;安卓开发领域上&lt;a href=&quot;https://github.com/square/okhttp&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Okhttp&lt;/a&gt;、&lt;a href=&quot;https://github.com/square/retrofit&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Retrofit&lt;/a&gt;、&lt;a href=&quot;https://github.com/ReactiveX/RxJava&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;RxJava&lt;/a&gt;无疑已经成为了开发过程中的三板斧。在安卓6.0中谷歌删除了HttpClient的相关代码，并且在系统层面上使用了OkHttp，因此足以说明了这个框架的优秀。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/android-cn/android-open-project-analysis&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;我们不重复造轮子不表示我们不需要知道轮子该怎么造及如何更好的造!&lt;/a&gt; &lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>记录-DockerCE安装</title>
    <link href="https://keep2iron.github.io/2017/09/06/%E8%AE%B0%E5%BD%95-DockerCE%E5%AE%89%E8%A3%85/"/>
    <id>https://keep2iron.github.io/2017/09/06/记录-DockerCE安装/</id>
    <published>2017-09-06T01:52:58.000Z</published>
    <updated>2018-08-19T08:06:04.863Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/EN8O4bt.png" width="680"></p><p>配置如下:<br>Ubuntu 16.04LTS(64位版本)</p><p>本文的大部分步骤来自于docker的官方文档</p><blockquote><p><a href="https://docs.docker.com/engine/installation/linux/docker-ce/ubuntu/" target="_blank" rel="noopener">https://docs.docker.com/engine/installation/linux/docker-ce/ubuntu/</a></p></blockquote><a id="more"></a><p><strong>Docker是一种容器化的一种技术</strong></p><p>由于docker目前分为了两个版本一个是商业版，一个是社区版，因此这里我们选择的是社区版也就是CE版本。</p><h5 id="Docker是一种类似虚拟机的一种技术，但是比虚拟机要轻量的多。"><a href="#Docker是一种类似虚拟机的一种技术，但是比虚拟机要轻量的多。" class="headerlink" title="Docker是一种类似虚拟机的一种技术，但是比虚拟机要轻量的多。"></a>Docker是一种类似虚拟机的一种技术，但是比虚拟机要轻量的多。</h5><h4 id="1-docker-ce安装的运行环境"><a href="#1-docker-ce安装的运行环境" class="headerlink" title="1.docker ce安装的运行环境"></a>1.docker ce安装的运行环境</h4><p>DockerCE的安装版本的要求</p><ul><li>Zesty 17.04</li><li>Xenial 16.04 (LTS)</li><li>Trusty 14.04 (LTS)</li></ul><p>如果你的系统是14.04版本则需要安装linux-image-extra-*，因为docker需要这两个包。</p><pre><code>sudo apt-get updatesudo apt-get install \linux-image-extra-$(uname -r) \linux-image-extra-virtual</code></pre><h4 id="2-删除之前版本的docker"><a href="#2-删除之前版本的docker" class="headerlink" title="2.删除之前版本的docker"></a>2.删除之前版本的docker</h4><p>之前版本的docker叫做docker或者docker-engine，如果之前安装过，卸载它们</p><pre><code>sudo apt-get remove docker docker-engine docker.io</code></pre><p>现在我们安装的docker的包名叫做<strong>docker-ce</strong></p><h4 id="3-安装docker-ce"><a href="#3-安装docker-ce" class="headerlink" title="3.安装docker-ce"></a>3.安装docker-ce</h4><p>1.更新包的索引</p><pre><code>sudo apt-get update</code></pre><p>2.安装允许让apt允许的ssl仓库的包(ps:\代表这句脚本没有写完，进行换行)</p><pre><code>sudo apt-get install \apt-transport-https \ca-certificates \curl \software-properties-common</code></pre><p>3.添加Docker GPG Key</p><pre><code>curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</code></pre><p>4.设置仓库地址,这里设置的x86的仓库地址</p><pre><code>sudo add-apt-repository \   &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \   $(lsb_release -cs) \   stable&quot;</code></pre><p>5.安装<br>ubuntu14.04以上的版本都是自带docker安装包的,所以可以直接安装,但是这个一般不是最新版本,所以一般需要进行更新源</p><pre><code>sudo apt-get updatesudo apt-get install docker.io</code></pre><p>2.安装完成了之后可以通过以下命令进行查看安装版本<br>    docker -v</p><p>3.下载docker的镜像</p><pre><code>docker run ubuntu:15.10 /bin/echo &quot;Hello world&quot;</code></pre><h5 id="重点来了！！镜像地址默认是国外的dockerhub，国内速度较慢，因此需要一个国内镜像去加速，这里使用的是的DaoCloud"><a href="#重点来了！！镜像地址默认是国外的dockerhub，国内速度较慢，因此需要一个国内镜像去加速，这里使用的是的DaoCloud" class="headerlink" title="重点来了！！镜像地址默认是国外的dockerhub，国内速度较慢，因此需要一个国内镜像去加速，这里使用的是的DaoCloud"></a>重点来了！！镜像地址默认是国外的dockerhub，国内速度较慢，因此需要一个国内镜像去加速，这里使用的是的DaoCloud</h5><p>如果本地没有ubuntu 15.10的镜像，那么docker会去从仓库中下载，但是下载的速度很慢。因此这里使用了Docker镜像的加速器</p><p><a href="https://www.daocloud.io/mirror#accelerator-doc" target="_blank" rel="noopener">https://www.daocloud.io/mirror#accelerator-doc</a></p><p>通过下面的命令即可完成配置加速器。</p><pre><code>curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://d606b909.m.daocloud.io</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.imgur.com/EN8O4bt.png&quot; width=&quot;680&quot;&gt;&lt;/p&gt;
&lt;p&gt;配置如下:&lt;br&gt;Ubuntu 16.04LTS(64位版本)&lt;/p&gt;
&lt;p&gt;本文的大部分步骤来自于docker的官方文档&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.docker.com/engine/installation/linux/docker-ce/ubuntu/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://docs.docker.com/engine/installation/linux/docker-ce/ubuntu/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Docker" scheme="https://keep2iron.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>炫酷ViewPager指示器效果</title>
    <link href="https://keep2iron.github.io/2017/07/31/%E7%82%AB%E9%85%B7ViewPager%E6%8C%87%E7%A4%BA%E5%99%A8%E6%95%88%E6%9E%9C/"/>
    <id>https://keep2iron.github.io/2017/07/31/炫酷ViewPager指示器效果/</id>
    <published>2017-07-31T10:12:34.000Z</published>
    <updated>2018-08-21T16:44:07.219Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://i.imgur.com/FRwSDei.gif" alt=""></p><h1 id="写在前面的话"><a href="#写在前面的话" class="headerlink" title="写在前面的话"></a>写在前面的话</h1><p>本文的源起是在有一天在网上看到的一个挺不错的一个效果而产生的一个想法，正好因为这段时间公司闲了下来，因此想着练习一下中定义view。</p><a id="more"></a><h5 id="本文以尽可能通俗的语言，让大家理解整个的绘制过程，尽量不粘贴代码-因为我认为思路往往比代码更重要-。还有就是可能对数学无感的人和不太友好。"><a href="#本文以尽可能通俗的语言，让大家理解整个的绘制过程，尽量不粘贴代码-因为我认为思路往往比代码更重要-。还有就是可能对数学无感的人和不太友好。" class="headerlink" title="本文以尽可能通俗的语言，让大家理解整个的绘制过程，尽量不粘贴代码(因为我认为思路往往比代码更重要)。还有就是可能对数学无感的人和不太友好。"></a>本文以尽可能通俗的语言，让大家理解整个的绘制过程，尽量不粘贴代码(因为我认为思路往往比代码更重要)。还有就是可能对数学无感的人和不太友好。</h5><h2 id="一、这篇文章你将会学到什么"><a href="#一、这篇文章你将会学到什么" class="headerlink" title="一、这篇文章你将会学到什么?"></a>一、这篇文章你将会学到什么?</h2><blockquote><p>1.学到一些自定义绘制中的一些技巧。</p><p>2.学习Bezier的一些相关知识。</p><p>3.利用面向对象更好的去解决一些复杂的问题。</p></blockquote><h2 id="二、准备"><a href="#二、准备" class="headerlink" title="二、准备"></a>二、准备</h2><h3 id="2-1-UI效果展示"><a href="#2-1-UI效果展示" class="headerlink" title="2.1 UI效果展示"></a>2.1 UI效果展示</h3><h3 id="原始效果图"><a href="#原始效果图" class="headerlink" title="原始效果图:"></a>原始效果图:</h3><p><img src="http://i.imgur.com/ybV4NBB.gif" alt=""></p><h3 id="实际运行图"><a href="#实际运行图" class="headerlink" title="实际运行图:"></a>实际运行图:</h3><p><img src="http://i.imgur.com/FRwSDei.gif" alt=""></p><h3 id="2-2-思考"><a href="#2-2-思考" class="headerlink" title="2.2 思考"></a>2.2 思考</h3><blockquote><p>1.界面由 ViewPager + 自定义指示器</p><p>2.ViewPager的间隔效果.</p><p>3.小球能够和ViewPager联动不断变化</p></blockquote><h3 id="2-3-ViewPager效果实现"><a href="#2-3-ViewPager效果实现" class="headerlink" title="2.3 ViewPager效果实现"></a>2.3 ViewPager效果实现</h3><p>我们看到上面的是一个可以滑动的ViewPager，但是默认的ViewPager是一页只能显示一个Item的，因此经过多方查找，我找到了如下方法可以实现这个效果:</p><h5 id="2-3-1-ViewPager的布局"><a href="#2-3-1-ViewPager的布局" class="headerlink" title="2.3.1 ViewPager的布局"></a>2.3.1 ViewPager的布局</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">android.support.v4.view.ViewPager</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:layout_above</span>=<span class="string">"@+id/bezierIndicator"</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:id</span>=<span class="string">"@+id/viewPager"</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:layout_centerVertical</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:layout_gravity</span>=<span class="string">"bottom"</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:clipToPadding</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:overScrollMode</span>=<span class="string">"never"</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:paddingBottom</span>=<span class="string">"10dp"</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:paddingEnd</span>=<span class="string">"@dimen/card_padding"</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:paddingLeft</span>=<span class="string">"@dimen/card_padding"</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:paddingRight</span>=<span class="string">"@dimen/card_padding"</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:paddingStart</span>=<span class="string">"@dimen/card_padding"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h5 id="android-clipToPadding-”false”"><a href="#android-clipToPadding-”false”" class="headerlink" title="android:clipToPadding=”false”"></a>android:clipToPadding=”false”</h5><p>就是说控件的绘制区域是否在padding里面的，true的情况下绘制的区域不包括了Padding占据的那部分<br><img src="http://i.imgur.com/uxdywV1.png" alt=""><br>蓝线的部分即为我们绘制的区域，因为设置了true，而且默认是true，而我们想要把绘制区域在padding中那么就要将这个属性设置为false了。</p><h5 id="android-overScrollMode-”never”"><a href="#android-overScrollMode-”never”" class="headerlink" title="android:overScrollMode=”never”"></a>android:overScrollMode=”never”</h5><p>我们滑动的时候经常可以看到谷歌很多滑动的原生控件上都具有一个明显的特征(5.0以上)<br><img src="http://i.imgur.com/DewB1bC.png" alt=""></p><p>有一个阴影对吧，这个效果默认是有的，这个效果的含义就是滑动的时候可以滑出区域外，有一个简单的回弹效果，如果不想要这个阴影，也就是这个回弹，那么可以将这个属性设置成never即可。</p><p>再来就是设置padding值。但是还有没结束。</p><h5 id="2-3-2-ViewPager的代码设置"><a href="#2-3-2-ViewPager的代码设置" class="headerlink" title="2.3.2 ViewPager的代码设置"></a>2.3.2 ViewPager的代码设置</h5><pre><code>mViewPager = (ViewPager) findViewById(R.id.viewPager);mViewPager.setOffscreenPageLimit(3);mViewPager.setPageMargin(60);</code></pre><p>1.设置viewpager缓存页数，因为默认ViewPager只加载一页，因此这里设置成三个，让其全部加载。<br>2.设置setPageMargin是为了控制每一页Page之间的大小。产生一个间隔的效果。这里和padding的不同在于Padding是设置了边界，也就是第一页左边的那个大小，因此这里是设置每一页之间的大小的。</p><p>经过了上面的配置，我们的ViewPager就可以完成了下面所示的效果<br><img src="http://i.imgur.com/TDZ8ZEf.png" alt=""></p><h3 id="2-4-BezierIndicator"><a href="#2-4-BezierIndicator" class="headerlink" title="2.4 BezierIndicator"></a>2.4 BezierIndicator</h3><p>上面我们一步一步实现了ViewPager的效果，接下来的重头戏就是如何去实现小球？</p><p>细心的我们可以发现这个球一共经历了5个状态，并且动画是<em>通过形状的变化加上画布的位移而产生</em>的<br><img src="http://i.imgur.com/rHwii48.png" alt=""><br><img src="http://i.imgur.com/987EBUH.gif" alt=""></p><p>下面我们来一步一步来进行Beizer的绘制工作</p><h4 id="2-4-1-预热一下"><a href="#2-4-1-预热一下" class="headerlink" title="2.4.1 预热一下"></a>2.4.1 预热一下</h4><p>在开始画之前我们先来看一下这个Beizer的相关api，关于Bezier的数学原理在这里不会详细阐述(网络上有大量的说明，如果有兴趣可以自行查阅)。</p><p>在具体的讲解之前，我们来看看如果利用Bezier画圆。</p><p>下面这个图利用了PS中的钢笔工具进行了绘制，也就是说这个圆是由4条Bezier曲线组成的。<br><img src="http://i.imgur.com/dMXbG4Q.png" alt=""></p><p>利用如下代码即可完成绘制<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mPath.cubicTo(x1,y1,x2,y2,x3,y3);//x1,x2都是控制点,x3是终点</span><br></pre></td></tr></table></figure></p><p><img src="http://i.imgur.com/i4jslVi.png" alt=""></p><p>P1 P2 P3 P4分别是圆上的4个端点,它们连线的圆点即为该点的控制点。M为控制点到圆点的距离,那么M值的大小直接影响了曲线变化！</p><p>代码如下:</p><pre><code>mPath.reset();mPath.reset();mPath.moveTo(p1.x, p1.y);mPath.cubicTo(p1.rightX, p1.rightY, p2.bottomX, p2.bottomY, p2.x, p2.y);mPath.cubicTo(p2.topX, p2.topY, p3.rightX, p3.rightY, p3.x, p3.y);mPath.cubicTo(p3.leftX, p3.leftY, p4.topX, p4.topY, p4.x, p4.y);mPath.cubicTo(p4.bottomX, p4.bottomY, p1.leftX, p1.leftY, p1.x, p1.y);</code></pre><p>代码中，先将Path移动到p1点</p><pre><code>mPath.moveTo(p1.x, p1.y)</code></pre><p>然后利用p1右边的控制点,p2下方的控制点，以及p2点的坐标即可画出p1到p2的曲线</p><pre><code>mPath.cubicTo(p1.rightX, p1.rightY, p2.bottomX, p2.bottomY, p2.x, p2.y);</code></pre><p>其他的跟上面的写法是一样的，就不再赘述。</p><p>p1,p3的控制点由于是在水平方向上的，于是控制点的计算使用了如下的代码:</p><pre><code>this.x = x;this.y = y;this.m = m;leftX = x - m;rightX = x + m;leftY = y;rightY = y;</code></pre><p>根据资料查询的结果: M =  <em>0.5522847498</em>时，曲线的绘制就是一个圆弧。</p><blockquote><p><a href="http://spencermortensen.com/articles/bezier-circle/" target="_blank" rel="noopener">http://spencermortensen.com/articles/bezier-circle/</a>有一篇文章专门讲解了M点计算的原理。</p></blockquote><h2 id="三、开始"><a href="#三、开始" class="headerlink" title="三、开始"></a>三、开始</h2><h4 id="3-1来面向对象一下"><a href="#3-1来面向对象一下" class="headerlink" title="3.1来面向对象一下"></a>3.1来面向对象一下</h4><p><img src="http://i.imgur.com/JpN6uGa.png" alt=""></p><p>首先将小球进行了抽象，抽取成一个单独的类<em>BerizerCircle</em>，然后画出小球的时候需要一些控制点的坐标。在这里我们分为了水平端点(<em>HorizontalPoint</em>)和垂直端点坐标(<em>VerticalPoint</em>)。</p><p>那么问题来了什么是水平端点和垂直端点呢？哈哈哈，其实这里我只是自己这么称呼的而已，不要介意。</p><p>水平端点即为在水平方向上具有控制点的点，对应了我们刚才图上所示的P1,P3的两个端点，那么垂直端点也就是P2、P4了</p><p>下面来看一下其中的<strong>HorizontalPoint.java</strong>的构造函数</p><pre><code>public HorizontalPoint(float x, float y, float m) {    this.x = x;    this.y = y;    this.m = m;    leftX = x - m;    rightX = x + m;    leftY = y;    rightY = y;}</code></pre><p>这个构造函数的意思就是，通过设置端点的坐标(x,y)，以及端点到控制点的距离(M)，即可得到端点坐标和两个控制点的坐标。那么VerticalPoint类的构造函数的思路也就不用多说了。</p><p>那么构造端点方法可以通过如下的方式进行了</p><pre><code>p1 = new HorizontalPoint(0, R, M);p2 = new VerticalPoint(R, 0, M);p3 = new HorizontalPoint(0, -R, M);p4 = new VerticalPoint(-R, 0, M);</code></pre><p>如果上述不是看的很懂那么再一个图来理解一下<br><img src="http://i.imgur.com/XgOAb5N.png" alt=""></p><p>那么利用R,M我们可以把图中所有的端点和控制点进行了计算。</p><h4 id="3-2绘制流程"><a href="#3-2绘制流程" class="headerlink" title="3.2绘制流程"></a>3.2绘制流程</h4><p>下面我们来看一下<em>BezierCircle</em>下面这个核心的函数，思路就是通过滑动的百分比，来控制图形的形态。</p><pre><code>/** * 通过ViewPager的百分比进行控制显示的状态 * * @param fromPos * @param toPos * @param positionOffset Value from [0, 1) indicating the offset from the page at position. * @see android.support.v4.view.ViewPager.OnPageChangeListener */public void drawByPositionOffset(int fromPos, int toPos, float positionOffset) {    boolean isTurnRight = toPos - fromPos &gt; 0;    if (positionOffset &gt;= 0 &amp;&amp; positionOffset &lt;= 0.2f) {        buildCircle1(positionOffset, isTurnRight);    } else if (positionOffset &lt;= 0.5f) {        buildCircle2(positionOffset, isTurnRight);    } else if (positionOffset &lt;= 0.8f) {        buildCircle3(positionOffset, isTurnRight);    } else if (positionOffset &lt;= 0.9f) {        buildCircle4(positionOffset, isTurnRight);    } else if (positionOffset &lt;= 1.0f) {        buildCircle5(positionOffset, isTurnRight);    }}</code></pre><p><img src="http://i.imgur.com/Q0YEXmf.png" alt=""></p><p>上图就是一个小球变化的一个趋势图，整体的一个绘制思路和流程在上图可以进行了完整的体现。</p><p>那么下面我们来具体分析一下，小球在各个滑动区间中具体是如何变化的吧！</p><p><strong>3.2.1平移距离在(0,0.2]的范围内时</strong></p><p><img src="http://i.imgur.com/ohP8VAU.gif" alt=""></p><p>p2点在这个状态的中从(R,0)变成了(9/5 *R,0),<strong>positionOffset / 0.2f为这个区间(0,0.2]的变化率</strong>。</p><blockquote><p>x = R + 4 / 5.0f <em> R </em> P,P是变化率也就是positionOffset / 0.2f</p></blockquote><p>下面是代码：</p><pre><code>/** * 因为变化率是0 - 0.2f区间进行变化, 而p2点的x坐标则是从R - 4/5R之间进行变化, * 因此x = R + (4/5R * (变化率的百分比)) * 变化率的百分比为 pos / 0.2f   0.2为区间值,pos在0 - 0.2f之间变化 * * @param positionOffset */private void buildCircle1(float positionOffset) {   //0 &lt; pos &lt;=0.2f    p1.setX(0);    p3.setX(0);    p4.setX(-R);    p2.setX(R + 4 / 5.0f * R * positionOffset / 0.2f);}</code></pre><p>如果对上面的公式或者注释你还是无法有一个直观的理解，可以结合下面的图来进行进一步的加深<br><img src="http://i.imgur.com/GdUdPvK.png" alt=""></p><p>在buildCircle1中我们做的就是将P2点的坐标不断进行水平移动，从而让小球从状态1变化到了状态2了。</p><p><strong>3.2.2平移距离在(0.2,0.5]的范围内时</strong></p><p><img src="http://i.imgur.com/mqA6dSV.gif" alt=""></p><p>在这个过程中我们需要将小球进行变化成一个椭圆<br>通过下图我们可以看到如果单纯将P2点垂直方向上的控制点的距离进行增大，图形的右边就更加的椭圆了，因为要对称，所以同时改变P2点和p4的垂直方向上M的距离，就可以让这两边的曲线更加接近椭圆。<br><img src="http://i.imgur.com/REGqLHG.png" alt=""></p><p>但是还有一个问题，图形目前是不对称的，在上一个状态中我们移动了p2点的坐标R-&gt;9/5R，因此要让P2和p4对称，因此p1和p3也要同时进行移动，让其两点的x轴的坐标移动到新的中心点坐标。</p><p><strong>新的中心点在哪里？</strong></p><p>我们重新来看下坐标<br>P1(0,R)，P2(5/9R,0),P3(0，-R),P4（-R,0）<br>新的中心点的x轴的坐标为</p><blockquote><p>x = (p4.x + (p2.x - p4.x) / 2) * P</p></blockquote><p>我们可以看到公式中有一个除2的操作，为什么要除2呢?<br><img src="http://i.imgur.com/Q6tTjLZ.png" alt=""></p><p><strong>可以看到正方形，通过将右边的左边的点进行平移1个单位后</strong>,中心点从(0,0)变化至(0.5,0)。通过这个公式p4.x + (p2.x - p4.x) / 2,这里我们将p2.x = 2，p4.x = -1，通过计算得出了0.5，因此这就是为什么要这么写的原因了。</p><p>下面是代码：</p><pre><code>/** * 在这个过程中需要将Circle变成一个椭圆 * 这个里p2点的x是R + 4 / 5R,因此椭圆的长轴的距离为 R+ R + 4 / 5R = 14 / 5R * &lt;p&gt; * 然后 14 / 5R /2 为长轴一半 - R即为椭圆中心点的坐标 * * @param positionOffset */private void buildCircle2(float positionOffset) {   //0.2 &lt; pos &lt;= 0.5f    p2.setX(R + 4 / 5.f * R);    float x = ((R + R + 4 / 5.f * R) / 2.f - R) * (positionOffset - 0.2f) / 0.3f;    p1.setX(x);    p3.setX(x);    float m = M + M * 2 / 3.f * (positionOffset - 0.2f) / 0.3f;    p4.setM(m);    p2.setM(m);}</code></pre><p><strong>3.2.3平移距离在(0.5,0.8]的范围内时</strong></p><p><img src="http://i.imgur.com/3GKt8Rv.gif" alt=""></p><p>在这个过程中我们需要将椭圆变成如我们状态2那样子的有一头比较尖的圆形。</p><p>p2.x从9/5R 变化至 R</p><p>p4.x从-R 变化至 -9/5R</p><p>p1.x从((R +  9/5R) / 2.f - R)/2 变化至 0</p><p>p3.x从((R +  9/5R) / 2.f - R)/2 变化至 0</p><pre><code>/** * 在这个过程中需要将circle从一个椭圆变成左边较尖锐的椭圆 * * @param positionOffset */private void buildCircle3(float positionOffset) {       //0.5 - 0.8f    float x = ((R + R + 4 / 5.f * R) / 2.f - R) - ((R + R + 4 / 5.f * R) / 2.f - R) * (positionOffset - 0.5f) / 0.3f;    p1.setX(x);    p3.setX(x);    float m = 5.f * M / 3 - 2.f * M / 3 * (positionOffset - 0.5f) / 0.3f;    p2.setM(m);    p4.setM(m);    float p4X = -R - 4 / 5.f * R * (positionOffset - 0.5f) / 0.3f;    p4.setX(p4X);    float p2X = 9 / 5.f * R - 4 / 5.f * R * (positionOffset - 0.5f) / 0.3f;    p2.setX(p2X);}</code></pre><p><strong>3.2.4恢复成圆形(0.8,0.9]</strong></p><p><img src="http://i.imgur.com/AZFm3Sd.gif" alt=""></p><p>p4.x 从-9/5R 变化至 -R。并且重置一下p1、p2、p3的坐标</p><pre><code>private void buildCircle4(float positionOffset) {       //0.8 - 1.0    float p4X = -9 / 5.f * R + 4 / 5.f * R * (positionOffset - 0.8f) / 0.2f;    p4.setX(p4X);    p1.setX(0);    p3.setX(0);    p2.setX(R);}</code></pre><p><strong>3.2.5让小球进行回弹起来吧[0.9,1.0]</strong></p><p><img src="http://i.imgur.com/kwXQmEN.gif" alt=""></p><pre><code>double value = Math.sin(Math.toRadians((positionOffset - 0.9f) / 0.1f * 180));p4.setX((float) (-R +  R / 2.0f * value));</code></pre><p>为社么这里使用了sin函数呢?<br><img src="http://i.imgur.com/L0qETmy.jpg" alt=""></p><p><strong>在sin函数中x在[0，π/2]y轴的变化过程是[0,1]，x在[π/2，π]之间y轴的变化过程是[1,0]，这个y轴的变化过程正好满足我们这里回弹过程的变化率！！！因此使用sin作为这里控制回弹效果的产生是再合适不过的了。</strong></p><p><strong>3.2.6让小球进行平移</strong></p><p>前面我们都是通过改变p1,p2,p3,p4的坐标来改变小球的形状，然而还要进行添加位移，这样才能形成一个完整的动画，我在这里有两个思路</p><p>1.通过drawPath方法，不断地改变小球的x,y的位置来进行，然而这个的代价就是所有的坐标点都需要进行变化加上平移距离，得出最后的点的坐标</p><p>2.通过Canvas的translate方法，移动画布来达到我们这里平移动画的产生效果，显然，这一种方法我们不需要进行坐标转变即可完成动画效果，因为本控件也是采用了这一种方案。</p><p><img src="http://i.imgur.com/cOCWL6Q.png" alt=""></p><pre><code>canvas.save();canvas.translate(mStartPoint.x        + translateMoveSize * mPercent        + (span + 2 * R) * mViewPagerPosition, mStartPoint.y);Path path = mBezierCircle.buildPath();mPaint.setColor(color);canvas.drawPath(path, mPaint);canvas.restore();</code></pre><p>mStartPoint.x是计算的小球的起始位置。</p><pre><code>mStartPoint = new Point(span + R, h / 2);</code></pre><p>translateMoveSize是小球移动的一个单位的距离，mPercent是移动的百分比，mViewPagerPosition当前Page的位置。mStartPoint.x 先让小球平移到初始位置,然后加上 (span + 2 <em> R) </em> mViewPagerPosition当前页滑动页的距离，然后加上滑动的百分比在滑动距离上的比值，计算出最后的平移距离。</p><p>span的计算是通过下面的公式进行等分的计算出来的距离。</p><pre><code>span = (getWidth() - (count * R * 2)) / (count + 1);</code></pre><p><strong>3.2.7绑定ViewPager进行联动</strong></p><p>监听ViewPager的滑动事件自然是通过addOnPageChanageListener进行滑动的监听。在这里我们使用了如下的方法：</p><pre><code>@Overridepublic void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) {    if (!isInitialise) return;    if (!isMoveByTouch) {        boolean right = position + positionOffset - mViewPagerPosition &gt; 0;        if (positionOffset != 0.0f) {            //位移未完成            startColor = roundColors[mViewPagerPosition];            endColor = roundColors[(mViewPagerPosition + (right ? 1 : -1)) % roundColors.length];            color = mBezierCircle.getCurrentColor(right ? positionOffset : 1 - positionOffset, startColor, endColor);        }        moveBezierCirclePercent(position, positionOffset);    }}</code></pre><p>在这里我们先来看一下ViewPager数值的变化规律:<br>这是从左向右滑动的时候,从第0页向第一页滑动position从0变化到1，positionOffset:0.0到0.999最后在完成翻页了之后变成了0.0.</p><p><img src="http://i.imgur.com/h5iaGTj.png" alt=""></p><p>这是从右向左滑动的时候</p><p><img src="http://i.imgur.com/p32wjpw.png" alt=""></p><pre><code>boolean right = position + positionOffset - mCurrentPosition &gt; 0;if (positionOffset != 0.0f) {    //位移未完成    startColor = roundColors[mCurrentPosition];    endColor = roundColors[mCurrentPosition + (right ? 1 : -1)];    color = mBezierCircle.getCurrentColor(right ? positionOffset : 1 - positionOffset, startColor, endColor);}moveBezierCirclePercent(position, positionOffset);</code></pre><p>这里是颜色的相关计算,mCurrentPosition是当前页的位置。</p><p>0到1页时,颜色值从a-b进行变化,变化率从0.0到0.9</p><p>1到0页时,颜色值从b-a进行变化,变化率从0.9到0.0,因此需要进行1 - positionOffset让其从0.0到0.9进行变化，才满足我们变化的颜色公式。</p><p>下面是颜色变化的计算函数</p><pre><code>public int getCurrentColor(float percent, int startColor, int endColor) {    f[0][0] = (startColor &amp; 0xff0000) &gt;&gt; 16;    f[0][1] = (startColor &amp; 0x00ff00) &gt;&gt; 8;    f[0][2] = (startColor &amp; 0x0000ff);    f[1][0] = (endColor &amp; 0xff0000) &gt;&gt; 16;    f[1][1] = (endColor &amp; 0x00ff00) &gt;&gt; 8;    f[1][2] = (endColor &amp; 0x0000ff);    for (int i = 0; i &lt; 3; i++) {        result[i] = (int) (f[0][i] + (f[1][i] - f[0][i]) * percent);    }    return Color.rgb(result[0], result[1], result[2]);}</code></pre><h4 id="3-3-点击产生的涟漪效果"><a href="#3-3-点击产生的涟漪效果" class="headerlink" title="3.3 点击产生的涟漪效果"></a>3.3 点击产生的涟漪效果</h4><p>实际的原理是通过属性动画进行改变画笔画圆的半径，然后通过设置画笔的粗细程度来完成这一效果的实现。</p><p>在onDraw方法画出点击的产生的圆</p><pre><code>private void drawTouchWave(Canvas canvas) {    if (mTouchPoint.isShow()) {        canvas.drawCircle(mTouchPoint.getCenterX(), mTouchPoint.getCenterY(), mTouchPoint.R, mTouchPoint.mPaint);    }}</code></pre><p>在onTouchEvent进行点击效果的触发</p><pre><code>private int getDistance(float x1, float y1, float x2, float y2) {    return (int) Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));}@Overridepublic boolean onTouchEvent(MotionEvent event) {    super.onTouchEvent(event);    switch (event.getActionMasked()) {        case MotionEvent.ACTION_DOWN:            for (int i = 0; i &lt; mBitmapRects.length; i++) {                int distance = getDistance(mBitmapRects[i].centerX(), mBitmapRects[i].centerY(), event.getX(), event.getY());                if (distance &lt;= R) {                    mTouchPoint.setCenterX((int) mBitmapRects[i].centerX());                    mTouchPoint.setCenterY((int) mBitmapRects[i].centerY());                    mTouchPoint.setShow(true);                    startWave();                    startMoveBezierCircleByTouch(mCurrentPosition, i);                    break;                }            }            break;    }    return true;}</code></pre><p>通过两点之间的距离公式，判断是否在点击的区域范围内，然后通过startWave()方法进行显示点击的涟漪效果，通过startMoveBezierCircleByTouch方法进行从当前位置，跳转的指定的位置的平移变换。</p><pre><code>/** * 开启点击的水波纹 */private void startWave() {    ValueAnimator valueAnimator = ValueAnimator.ofFloat(R, 4.0f / 3 * R);    valueAnimator.setDuration(400);    valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {        @Override        public void onAnimationUpdate(ValueAnimator animation) {            float value = (float) animation.getAnimatedValue();            float percent = (value - R) / (1.f / 3 * R);            mTouchPoint.setStrokeWidth(TouchPoint.STROKE_WIDTH * (1 - percent));            mTouchPoint.R = value;            invalidate();        }    });    valueAnimator.addListener(new AnimatorListenerAdapter() {        @Override        public void onAnimationEnd(Animator animation) {            mTouchPoint.setShow(false);            invalidate();        }    });    valueAnimator.start();}</code></pre><p>通过改变R的半径以及画笔的粗细程度，即可完成了这一效果的绘制过程</p><p><img src="http://i.imgur.com/nBVpmbw.gif" alt=""></p><h3 id="3-4-点击产生的位移"><a href="#3-4-点击产生的位移" class="headerlink" title="3.4 点击产生的位移"></a>3.4 点击产生的位移</h3><p>上面我们看到点击后通过属性动画完成涟漪效果的显示，<strong>同样我们可以利用属性动画，让其模拟viewPager的参数的变化过程，这样之前的ViewPager函数就可以进行调用就行了</strong>。</p><pre><code>private void startMoveBezierCircleByTouch(final int formPos, final int toPos) {    if (formPos == toPos) return;    final boolean isTurnRight = toPos - formPos &gt; 0;    translateMoveSize = Math.abs(toPos - formPos) * (span + 2 * R);    setDurationScroller();    //位移未完成    startColor = roundColors[formPos];    endColor = roundColors[toPos];    mViewPager.setCurrentItem(toPos);    ValueAnimator valueAnimator = ValueAnimator.ofInt(0, Math.abs(translateMoveSize));    valueAnimator.setDuration(600);    valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {        @Override        public void onAnimationUpdate(ValueAnimator animation) {            isMoveByTouch = true;            int value = (int) animation.getAnimatedValue();            float percent = Math.abs(value * 1.0f) / Math.abs((toPos - formPos) * (span + 2 * R));            color = mBezierCircle.getCurrentColor(percent, startColor, endColor);            if (percent &gt;= 1.0f) {                isMoveByTouch = false;                translateMoveSize = span + 2 * R;                mViewPagerPosition = toPos;                setOriginScroller();                moveBezierCirclePercent(toPos, 0.0f);            } else {                moveBezierCirclePercent(isTurnRight ? formPos : toPos, isTurnRight ? percent : 1 - percent);            }        }    });    valueAnimator.start();}</code></pre><p>因为ViewPager在0页到1页的过程中position是0，positionOffset是0-0.9直到当滑动完成后变成了0，1页到0页的过程中positionOffset是从0.9 - 0，position是0，因此这里就是模拟这样子的参数而编写代码。</p><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>现在看一下之前的问题，看看心里有没有数</p><pre><code>do{    1.ViewPager一页显示多个item？    2.如何进行绘制一个不断变化的小球？    3.如何让小球进行和ViewPager的进行绑定？    4.如何让小球不断的进行变化？    5.如何生成点击后的涟漪效果？}while(不懂);</code></pre><p><img src="http://i.imgur.com/dhsnvVB.png" alt=""></p><p>最后非常感谢<strong><em>陈宇明</em></strong>大佬的细心指导,文章的结构顺序、还有内容都一一进行指正和阅读，很多地方都是根据其建议进行修改的。</p><p>本篇的分析就到此为止了，后面我会抽时间不断的完善这个demo，如果你有好的建议，请加Bravh交流群和我一起交流/学习，我在等你哟~！</p><h3 id="本项目地址"><a href="#本项目地址" class="headerlink" title="本项目地址"></a>本项目地址</h3><blockquote><p><a href="https://github.com/keep2iron/BezierIndicator" target="_blank" rel="noopener">https://github.com/keep2iron/BezierIndicator</a></p></blockquote><h5 id="在编写代码的过程中也并不是一帆风顺的，再次感谢广大的博主和开源作者，Android社区的繁荣离不开你们辛勤的劳动。下面是参考的博客地址和项目地址"><a href="#在编写代码的过程中也并不是一帆风顺的，再次感谢广大的博主和开源作者，Android社区的繁荣离不开你们辛勤的劳动。下面是参考的博客地址和项目地址" class="headerlink" title="在编写代码的过程中也并不是一帆风顺的，再次感谢广大的博主和开源作者，Android社区的繁荣离不开你们辛勤的劳动。下面是参考的博客地址和项目地址"></a>在编写代码的过程中也并不是一帆风顺的，再次感谢广大的博主和开源作者，Android社区的繁荣离不开你们辛勤的劳动。下面是参考的博客地址和项目地址</h5><blockquote><p><a href="http://blog.csdn.net/zanelove/article/details/50337623" target="_blank" rel="noopener">http://blog.csdn.net/zanelove/article/details/50337623</a></p><p><a href="http://www.jianshu.com/p/791d3a791ec2" target="_blank" rel="noopener">http://www.jianshu.com/p/791d3a791ec2</a></p><p><a href="https://github.com/Ulez/DropIndicator" target="_blank" rel="noopener">https://github.com/Ulez/DropIndicator</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://i.imgur.com/FRwSDei.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;写在前面的话&quot;&gt;&lt;a href=&quot;#写在前面的话&quot; class=&quot;headerlink&quot; title=&quot;写在前面的话&quot;&gt;&lt;/a&gt;写在前面的话&lt;/h1&gt;&lt;p&gt;本文的源起是在有一天在网上看到的一个挺不错的一个效果而产生的一个想法，正好因为这段时间公司闲了下来，因此想着练习一下中定义view。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Simple Record" scheme="https://keep2iron.github.io/tags/Simple-Record/"/>
    
  </entry>
  
  <entry>
    <title>编写一个编译时注入框架</title>
    <link href="https://keep2iron.github.io/2017/05/28/%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E7%BC%96%E8%AF%91%E6%97%B6%E6%B3%A8%E5%85%A5%E6%A1%86%E6%9E%B6/"/>
    <id>https://keep2iron.github.io/2017/05/28/编写一个编译时注入框架/</id>
    <published>2017-05-28T09:40:00.000Z</published>
    <updated>2017-05-28T15:02:44.663Z</updated>
    
    <content type="html"><![CDATA[<p>最近在折腾AnnotationProcessor，想着通过学习黄油刀来编写一个自己android编译时注入框架。<br>这个项目的地址是我的自己编写的一个AnnotationProcessor库</p><blockquote><p><strong><a href="https://github.com/keep2iron/Fast4Android-InjectView" target="_blank" rel="noopener">https://github.com/keep2iron/Fast4Android-InjectView</a></strong><br>如果觉得这篇文章有点用，请记得给个star哟</p></blockquote><p>学习的过程中发现了一些需要知道的api，在了解了这些api的情况下，那么我相信你可以对这个东西的掌握会更加的熟练和精通。</p><p>下面是我用到相关api，<strong>请在了解这些api的基础上阅读代码，这样可以事半功倍哟。</strong><br><strong>javax.annotation.processing</strong><br>这个包用来声明注释处理器并允许注释处理器与注释处理工具环境通信的工具。 <table><tr><th style="text-algin:center;">类名</th><th style="text-algin:center;">说明</th></tr><tr><td>interface ExecutableElement</td><td>表示某个类或接口的方法、构造方法或初始化程序（静态或实例）,包括注释类型元素.</td></tr><tr><td>interface PackageElement</td><td>表示一个包程序元素.</td></tr><tr><td>interface TypeElement </td><td>表示一个类或接口程序元素.</td></tr><tr><td>interface TypeParameterElement </td><td>表示一般类、接口、方法或构造方法元素的形式类型参数.</td></tr><tr><td>interface     VariableElement </td><td>表示一个字段、enum 常量、方法或构造方法参数、局部变量或异常参数.</td></tr></table></p><blockquote><p>其中还运用到了<a href="https://github.com/square/javapoet" target="_blank" rel="noopener">javapoet</a>的相关api，利用这个库的api进行生成java代码。</p></blockquote><blockquote><p>使用了@AutoService这个是google的一个类库<a href="https://github.com/google/auto" target="_blank" rel="noopener">Auto</a>用来进行生成META-INF信息,这样可以不用我们自己手动去配置了</p></blockquote><p><strong>编译时顺序图</strong>点击下图选中的gradle脚本即可生成文件</p><p><img src="http://i.imgur.com/QZyE8lR.png" alt=""></p><p><strong>在代码中调用bind方法的顺序图</strong></p><p><img src="http://i.imgur.com/6ELqej3.png" alt=""></p><p><strong>生成文件执行的顺序图</strong><br><img src="http://i.imgur.com/mZoLFXQ.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在折腾AnnotationProcessor，想着通过学习黄油刀来编写一个自己android编译时注入框架。&lt;br&gt;这个项目的地址是我的自己编写的一个AnnotationProcessor库&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;ht
      
    
    </summary>
    
    
      <category term="Android" scheme="https://keep2iron.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>记录AndroidProcess调试</title>
    <link href="https://keep2iron.github.io/2017/05/26/%E8%AE%B0%E5%BD%95AndroidProcess%E8%B0%83%E8%AF%95/"/>
    <id>https://keep2iron.github.io/2017/05/26/记录AndroidProcess调试/</id>
    <published>2017-05-26T07:48:42.000Z</published>
    <updated>2018-08-19T05:55:54.307Z</updated>
    
    <content type="html"><![CDATA[<p>记录AndroidProcess调试步骤</p><p><strong>第一步</strong>在AnnoProcessor中设置断点</p><p><img src="http://i.imgur.com/gWBxFFT.png" alt=""></p><a id="more"></a><blockquote><p>记录AndroidProcess调试步骤</p><p><strong>第一步</strong>在AnnoProcessor中设置断点</p><p><img src="http://i.imgur.com/gWBxFFT.png" alt=""></p><p><strong>第二步</strong>修改</p><p>gradle.properties</p><p><strong>第三步</strong>添加如下代码</p><p>第一行的作用是允许gradle开启守护进程</p><p>第二行代码是设置gradle连接的端口号.这里原先是设置为5005，但是由于报错，说端口号被占用，因此改为5010</p><p><code>org.gradle.daemon=true</code></p><p><code>org.gradle.jvmargs=-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5010</code></p><p><strong>第四步</strong>在上一步的基础上在as控制台运行如下命令：</p><p><code>gradle --daemon</code></p><p>你可能会有如下的报错：</p><p><img src="http://i.imgur.com/gMRzcuZ.png" alt=""></p><p><strong>少年莫慌，这是因为gradle没有在你的电脑中配置的缘故，因此可以将gradle改成gradlew！！！！！</strong></p><p>gradlew相当于是gradle的一个包装，相当于接口，因此实现类是由，.gradle文件夹中的gradle-wrapper.properties中的distributionUrl后面指定的gradle版本决定的<strong>（PS:在这里可以看到面向接口的好处了吧）</strong></p><p>运行完成之后，gradle就已经开启了守护进程，他会监听在我们刚刚配置的指定的端口号上</p><p><strong>第五步</strong>配置AndroidStudio</p><p><img src="http://i.imgur.com/lmCs3Wd.png" alt=""></p><p><img src="http://i.imgur.com/B1tGwYV.png" alt=""></p><p><img src="http://i.imgur.com/y0vgumU.png" alt=""></p><p><strong>然后点击ok就可以了</strong>然后界面上就有这个配置项了，下面开始运行它，点击那个小虫子的图标，debug模式运行</p><p><img src="http://i.imgur.com/RQNGkba.png" alt=""></p><p><img src="http://i.imgur.com/hmokmXh.png" alt=""></p><p><strong>第五步</strong>最后一步啦，在命令行执行如下命令，让其进行编译，因此我们</p><p><code>gradle clean assembleDebug</code></p><p>在运行的过程中</p><p><img src="http://i.imgur.com/jivxUeh.png" alt=""></p><p>这里可以看到我们的断点执行啦！！ok到此AnnotationProcessor的调试就到此结束了~！</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录AndroidProcess调试步骤&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一步&lt;/strong&gt;在AnnoProcessor中设置断点&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/gWBxFFT.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="https://keep2iron.github.io/tags/Android/"/>
    
  </entry>
  
</feed>
