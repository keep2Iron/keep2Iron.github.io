<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Keep2iron&#39;s Road to development</title>
  
  <subtitle>Keep2iron&#39;s Road to development</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://keep2iron.github.io/"/>
  <updated>2019-09-02T02:40:25.921Z</updated>
  <id>https://keep2iron.github.io/</id>
  
  <author>
    <name>Keep2iron</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>一次迟来的总结和规划</title>
    <link href="https://keep2iron.github.io/2019/09/02/%E4%B8%80%E6%AC%A1%E8%BF%9F%E6%9D%A5%E7%9A%84%E6%80%BB%E7%BB%93%E5%92%8C%E8%A7%84%E5%88%92/"/>
    <id>https://keep2iron.github.io/2019/09/02/一次迟来的总结和规划/</id>
    <published>2019-09-02T02:11:13.000Z</published>
    <updated>2019-09-02T02:40:25.921Z</updated>
    
    <content type="html"><![CDATA[<p><img src="android10.webp" alt="总结"></p><h1 id="一次迟来的总结和规划"><a href="#一次迟来的总结和规划" class="headerlink" title="一次迟来的总结和规划"></a>一次迟来的总结和规划</h1><p>2019年来到了深圳这个地方一年了,给我的感觉是发展和节奏都比武汉快了,无论是技术和生活.自从毕业了之后时间的齿轮仿佛一刻不停的加速转动转动.</p><p>好在今年很高兴自己养成了一些好的习惯,比如健身,比如终于开始了决心要开始做一点新的东西和尝试(主要是工作上的总结和封装).</p><h3 id="Fast4Android"><a href="#Fast4Android" class="headerlink" title="Fast4Android"></a>Fast4Android</h3><p><img src="fast4android.png" alt="fast4android"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;android10.webp&quot; alt=&quot;总结&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;一次迟来的总结和规划&quot;&gt;&lt;a href=&quot;#一次迟来的总结和规划&quot; class=&quot;headerlink&quot; title=&quot;一次迟来的总结和规划&quot;&gt;&lt;/a&gt;一次迟来的总结和规划&lt;/h
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android Theme指北</title>
    <link href="https://keep2iron.github.io/2019/08/29/Android%20Theme%E6%8C%87%E5%8C%97/"/>
    <id>https://keep2iron.github.io/2019/08/29/Android Theme指北/</id>
    <published>2019-08-29T01:46:27.000Z</published>
    <updated>2019-08-29T01:47:38.816Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="android" scheme="https://keep2iron.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>Android绘制流程</title>
    <link href="https://keep2iron.github.io/2019/03/31/Android%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/"/>
    <id>https://keep2iron.github.io/2019/03/31/Android绘制流程/</id>
    <published>2019-03-31T14:39:47.000Z</published>
    <updated>2019-03-31T15:32:35.467Z</updated>
    
    <content type="html"><![CDATA[<h1 id="What"><a href="#What" class="headerlink" title="What"></a>What</h1><p>绘制流程的三个核心函数<strong>onMeasure（测绘控件的大小）</strong>、<strong>onLayout（设置控件相对于父布局的位置）</strong>、<strong>onDraw（控件要绘制什么样的东西）</strong>，以上的三个步骤全部都是在UI线程中完成操作，今天就主要来进行讨论这三个函数在Android系统的中调用逻辑。</p><blockquote><p> 由于60fps帧率的需要，又由于需要在1秒内(1s = 1000ms)完成刷新60帧的操作，因此得出以下结论</p><p> 1000 / 60 = 16.667 ms/fps</p><p> Android会每隔16.667ms进行绘制，因此我们的绘制流程需要在这段时间内完成，不然就会产生我们俗称的卡顿或者ANR（Application Not Responding）。</p></blockquote><h1 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h1><p>那么为什么要进行设计这三个流程呢？这就要从Android设计中独有的宽高单位中的<strong>Match_Parent、Wrap_Content、声明式大小、</strong>三种设计有关系。Match_Parent和Wrap_Content是设置控件大小的两种参数后面简称为Match和Wrap。</p><h4 id="onMeasure"><a href="#onMeasure" class="headerlink" title="onMeasure"></a>onMeasure</h4><p>Match是填充父控件的大小、Wrap是进行自适应包裹，这两者我们在使用时，例如像LinearLayout等一些控件时发现它的大小系统自动帮我们计算好了，而宽高大小的计算流程便是写在了<strong>onMeasure</strong>中。</p><h4 id="onLayout"><a href="#onLayout" class="headerlink" title="onLayout"></a>onLayout</h4><p>例如：LinearLayout通过设置Orientation属性之后进行item在一定方向上的有序排列。FrameLayout则是通过margin、layout_gravity进行设置item针对父布局的层级排列。这些item在布局中逻辑就是在<strong>onLayout</strong>中完成的。</p><h4 id="onDraw"><a href="#onDraw" class="headerlink" title="onDraw"></a>onDraw</h4><p>View中的空实现由各个集成自View的控件各自实现逻辑完成。</p><h1 id="How"><a href="#How" class="headerlink" title="How"></a>How</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;What&quot;&gt;&lt;a href=&quot;#What&quot; class=&quot;headerlink&quot; title=&quot;What&quot;&gt;&lt;/a&gt;What&lt;/h1&gt;&lt;p&gt;绘制流程的三个核心函数&lt;strong&gt;onMeasure（测绘控件的大小）&lt;/strong&gt;、&lt;strong&gt;onLayou
      
    
    </summary>
    
    
      <category term="UI" scheme="https://keep2iron.github.io/tags/UI/"/>
    
  </entry>
  
  <entry>
    <title>大话Http</title>
    <link href="https://keep2iron.github.io/2019/03/29/%E5%A4%A7%E8%AF%9DHttp/"/>
    <id>https://keep2iron.github.io/2019/03/29/大话Http/</id>
    <published>2019-03-29T02:17:14.000Z</published>
    <updated>2019-03-29T03:03:18.214Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>HyperText Transfer Protocol 超文本传输协议</p></blockquote><ul><li>超文本：在电脑中显示的，可以指向其他链接的文本</li></ul><h2 id="报文"><a href="#报文" class="headerlink" title="报文"></a>报文</h2><p>HTTP报文是在HTTP应用程序之间发送的数据块。这些数据块以一些文本形式的<em>元信息(meta-infomation)</em>开头，这些信息描述了报文的内容及含义，后面跟着可选的数据部分。</p><h4 id="报文的语法（Message-Syntax）"><a href="#报文的语法（Message-Syntax）" class="headerlink" title="报文的语法（Message Syntax）"></a>报文的语法（Message Syntax）</h4><p>HTTP报文是简单的格式化数据块。每条报文都包含一条来自客户端的请求，或者一条来自服务器的响应。它们由三个部分组成：对报文进行描述的<em>起始行（start line）</em>、包含属性的<em>首部（Header）块，以及可选的包含数据的主题（Body）部分。</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP-message = start-line</span><br><span class="line">   *( header-field CRLF)</span><br><span class="line">CRLF</span><br><span class="line">[ message-body]</span><br></pre></td></tr></table></figure></p><h4 id="报文分类与格式"><a href="#报文分类与格式" class="headerlink" title="报文分类与格式"></a>报文分类与格式</h4><h4 id="请求示例"><a href="#请求示例" class="headerlink" title="请求示例"></a>请求示例</h4><p><img src="https://i.imgur.com/eP4NtPS.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;HyperText Transfer Protocol 超文本传输协议&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;超文本：在电脑中显示的，可以指向其他链接的文本&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;报文&quot;&gt;&lt;a href=&quot;#报文&quot; 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>桶排序 &amp; 冒泡排序</title>
    <link href="https://keep2iron.github.io/2019/03/28/%E6%A1%B6%E6%8E%92%E5%BA%8F&amp;%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    <id>https://keep2iron.github.io/2019/03/28/桶排序&amp;冒泡排序/</id>
    <published>2019-03-28T07:41:58.000Z</published>
    <updated>2019-03-28T08:19:41.296Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/I6WksMT.jpg" width="680px"></p><blockquote><p><a href="https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">维基百科-快速排序</a><br><a href="https://zh.wikipedia.org/wiki/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">维基百科-归并排序</a><br><a href="https://www.cnblogs.com/onepixel/articles/7674659.html" target="_blank" rel="noopener">cnblog-排序算法</a></p></blockquote><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p></p><p>利用了空间换时间的概念,开辟了一个单位大小的数组 然后排序时让数据直接在这个数组的指定位置加一表示这个数据的数量，而数据本身的大小则被替换成数组下标的index，因此利用这个特性能够实现o1复杂度的排序。</p><p></p><h4 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h4><p>桶排序是一种直接的排序算法，利用数组下标本身有序的特点，使用空间换时间的概念而进行的排序。</p><ul><li>首先找到数列中<strong>最大值(max)</strong>和<strong>最小值(min)</strong></li><li>然后创建一个大小为max - min + 1的数组</li><li>遍历源数列，取出原数列中的元素，创建偏移函数使之从 0 开始计数</li></ul><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public static void bucketSort(int[] arr) &#123;</span><br><span class="line">    int max = 0;</span><br><span class="line">    int min = Integer.MAX_VALUE;</span><br><span class="line">    for (int i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        if (min &gt; arr[i]) &#123;</span><br><span class="line">            min = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        if (max &lt; arr[i]) &#123;</span><br><span class="line">            max = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int[] results = new int[max - min + 1];</span><br><span class="line">    for (int i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        results[adjustIndex(min, arr[i])]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int i = 0, index = 0;</span><br><span class="line">    while (i &lt; results.length) &#123;</span><br><span class="line">        if (results[i] != 0) &#123;</span><br><span class="line">            arr[index++] = min + i;</span><br><span class="line">            results[i]--;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static int adjustIndex(int min, int value) &#123;</span><br><span class="line">    return value - min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>冒泡排序是一种简单的排序算法。<strong>它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。</strong>这个算法的名字的由来是因为越小的元素会经由交换慢慢”浮”到数列的顶端。</p><h4 id="算法描述-1"><a href="#算法描述-1" class="headerlink" title="算法描述"></a>算法描述</h4><ul><li>每一轮最大（小）的元素则会浮到最后一个元素</li><li>执行 n -1 轮</li><li>每一轮中比较相邻的元素。如果第一个比第二个大（小），则进行交换，第i轮时（i从0开始）则进行比较前n - 1 - i 个元素。</li><li>重复执行 1 ~ 3直到结束</li></ul><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void bubbleSort(int[] arr)&#123;</span><br><span class="line">   for (int i = 1; i &lt; arr.length; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; arr.length - i; j++) &#123;</span><br><span class="line">            if (arr[j + 1] &lt; arr[j]) &#123;</span><br><span class="line">                int temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + 1];</span><br><span class="line">                arr[j + 1] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="动图展示"><a href="#动图展示" class="headerlink" title="动图展示"></a>动图展示</h4><p><img src="https://i.imgur.com/dm1RmOC.gif" width="680px"><br><a id="more"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.imgur.com/I6WksMT.jpg&quot; width=&quot;680px&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;维基百科-快速排序&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;维基百科-归并排序&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.cnblogs.com/onepixel/articles/7674659.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;cnblog-排序算法&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;桶排序&quot;&gt;&lt;a href=&quot;#桶排序&quot; class=&quot;headerlink&quot; title=&quot;桶排序&quot;&gt;&lt;/a&gt;桶排序&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;利用了空间换时间的概念,开辟了一个单位大小的数组 然后排序时让数据直接在这个数组的指定位置加一表示这个数据的数量，而数据本身的大小则被替换成数组下标的index，因此利用这个特性能够实现o1复杂度的排序。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;h4 id=&quot;算法描述&quot;&gt;&lt;a href=&quot;#算法描述&quot; class=&quot;headerlink&quot; title=&quot;算法描述&quot;&gt;&lt;/a&gt;算法描述&lt;/h4&gt;&lt;p&gt;桶排序是一种直接的排序算法，利用数组下标本身有序的特点，使用空间换时间的概念而进行的排序。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先找到数列中&lt;strong&gt;最大值(max)&lt;/strong&gt;和&lt;strong&gt;最小值(min)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;然后创建一个大小为max - min + 1的数组&lt;/li&gt;
&lt;li&gt;遍历源数列，取出原数列中的元素，创建偏移函数使之从 0 开始计数&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;代码实现&quot;&gt;&lt;a href=&quot;#代码实现&quot; class=&quot;headerlink&quot; title=&quot;代码实现&quot;&gt;&lt;/a&gt;代码实现&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public static void bucketSort(int[] arr) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int max = 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int min = Integer.MAX_VALUE;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    for (int i = 0; i &amp;lt; arr.length; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if (min &amp;gt; arr[i]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            min = arr[i];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if (max &amp;lt; arr[i]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            max = arr[i];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int[] results = new int[max - min + 1];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    for (int i = 0; i &amp;lt; arr.length; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        results[adjustIndex(min, arr[i])]++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int i = 0, index = 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    while (i &amp;lt; results.length) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if (results[i] != 0) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            arr[index++] = min + i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            results[i]--;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; else &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            i++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;private static int adjustIndex(int min, int value) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return value - min;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;冒泡排序&quot;&gt;&lt;a href=&quot;#冒泡排序&quot; class=&quot;headerlink&quot; title=&quot;冒泡排序&quot;&gt;&lt;/a&gt;冒泡排序&lt;/h2&gt;&lt;p&gt;冒泡排序是一种简单的排序算法。&lt;strong&gt;它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。&lt;/strong&gt;这个算法的名字的由来是因为越小的元素会经由交换慢慢”浮”到数列的顶端。&lt;/p&gt;
&lt;h4 id=&quot;算法描述-1&quot;&gt;&lt;a href=&quot;#算法描述-1&quot; class=&quot;headerlink&quot; title=&quot;算法描述&quot;&gt;&lt;/a&gt;算法描述&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;每一轮最大（小）的元素则会浮到最后一个元素&lt;/li&gt;
&lt;li&gt;执行 n -1 轮&lt;/li&gt;
&lt;li&gt;每一轮中比较相邻的元素。如果第一个比第二个大（小），则进行交换，第i轮时（i从0开始）则进行比较前n - 1 - i 个元素。&lt;/li&gt;
&lt;li&gt;重复执行 1 ~ 3直到结束&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;代码实现-1&quot;&gt;&lt;a href=&quot;#代码实现-1&quot; class=&quot;headerlink&quot; title=&quot;代码实现&quot;&gt;&lt;/a&gt;代码实现&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public void bubbleSort(int[] arr)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   for (int i = 1; i &amp;lt; arr.length; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        for (int j = 0; j &amp;lt; arr.length - i; j++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            if (arr[j + 1] &amp;lt; arr[j]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                int temp = arr[j];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                arr[j] = arr[j + 1];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                arr[j + 1] = temp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;动图展示&quot;&gt;&lt;a href=&quot;#动图展示&quot; class=&quot;headerlink&quot; title=&quot;动图展示&quot;&gt;&lt;/a&gt;动图展示&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/dm1RmOC.gif&quot; width=&quot;680px&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://keep2iron.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>快速排序</title>
    <link href="https://keep2iron.github.io/2019/03/28/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <id>https://keep2iron.github.io/2019/03/28/快速排序/</id>
    <published>2019-03-28T07:41:58.000Z</published>
    <updated>2019-03-29T02:09:00.925Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/I6WksMT.jpg" width="680px"></p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h4 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h4><ul><li>挑选基准值：从数列中挑出一个元素，称为“基准”（pivot），</li><li>分割：重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（与基准值相等的数可以到任何一边）。在这- 个分割结束之后，对基准值的排序就已经完成，</li><li>递归排序子序列：递归地将小于基准值元素的子序列和大于基准值元素的子序列排序。</li></ul><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  * 快速排序（非递归版）</span><br><span class="line">  */</span><br><span class="line">private static void quickSortByNotRecursive(int[] arr) &#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">    stack.push(arr.length - 1);</span><br><span class="line">    stack.push(0);</span><br><span class="line"></span><br><span class="line">    while (!stack.isEmpty()) &#123;</span><br><span class="line">        Integer newStart = stack.pop();</span><br><span class="line">        Integer newEnd = stack.pop();</span><br><span class="line"></span><br><span class="line">        int partition = partition(arr, newStart, newEnd);</span><br><span class="line">        if (newStart &lt; partition - 1) &#123;</span><br><span class="line">            stack.push(partition - 1);</span><br><span class="line">            stack.push(newStart);</span><br><span class="line">        &#125;</span><br><span class="line">        if (partition + 1 &lt; newEnd) &#123;</span><br><span class="line">            stack.push(newEnd);</span><br><span class="line">            stack.push(partition + 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">  * 快速排序（递归版）</span><br><span class="line">  */</span><br><span class="line">private static void quickSortByRecursive(int[] arr, int start, int end) &#123;</span><br><span class="line">    if (start &gt;= end) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int partIndex = partition(arr, start, end);</span><br><span class="line"></span><br><span class="line">    quickSortByRecursive(arr, start, partIndex - 1);</span><br><span class="line">    quickSortByRecursive(arr, partIndex + 1, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">  * 分区算法</span><br><span class="line">  */</span><br><span class="line">private static int partition(int[] arr, int start, int end) &#123;</span><br><span class="line">    if (start &lt; end) &#123;</span><br><span class="line">        int pivot = arr[start];</span><br><span class="line">        while (start &lt; end) &#123;</span><br><span class="line">            while (start &lt; end &amp;&amp; arr[end] &gt;= pivot) end--;</span><br><span class="line">            arr[start] = arr[end];</span><br><span class="line">            while (start &lt; end &amp;&amp; arr[start] &lt;= pivot) start++;</span><br><span class="line">            arr[end] = arr[start];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        arr[start] = pivot;</span><br><span class="line">    &#125;</span><br><span class="line">    return start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="动图演示"><a href="#动图演示" class="headerlink" title="动图演示"></a>动图演示</h4><p><img src="https://i.imgur.com/hHPWj2c.gif" alt><br><a id="more"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.imgur.com/I6WksMT.jpg&quot; width=&quot;680px&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;快速排序&quot;&gt;&lt;a href=&quot;#快速排序&quot; class=&quot;headerlink&quot; title=&quot;快速排序&quot;&gt;&lt;/a&gt;快速排序&lt;/h2&gt;&lt;h4 id=&quot;算法描述&quot;&gt;&lt;a href=&quot;#算法描述&quot; class=&quot;headerlink&quot; title=&quot;算法描述&quot;&gt;&lt;/a&gt;算法描述&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;挑选基准值：从数列中挑出一个元素，称为“基准”（pivot），&lt;/li&gt;
&lt;li&gt;分割：重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（与基准值相等的数可以到任何一边）。在这- 个分割结束之后，对基准值的排序就已经完成，&lt;/li&gt;
&lt;li&gt;递归排序子序列：递归地将小于基准值元素的子序列和大于基准值元素的子序列排序。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;代码实现&quot;&gt;&lt;a href=&quot;#代码实现&quot; class=&quot;headerlink&quot; title=&quot;代码实现&quot;&gt;&lt;/a&gt;代码实现&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  * 快速排序（非递归版）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;private static void quickSortByNotRecursive(int[] arr) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Stack&amp;lt;Integer&amp;gt; stack = new Stack&amp;lt;&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    stack.push(arr.length - 1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    stack.push(0);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    while (!stack.isEmpty()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Integer newStart = stack.pop();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Integer newEnd = stack.pop();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        int partition = partition(arr, newStart, newEnd);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if (newStart &amp;lt; partition - 1) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            stack.push(partition - 1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            stack.push(newStart);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if (partition + 1 &amp;lt; newEnd) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            stack.push(newEnd);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            stack.push(partition + 1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  * 快速排序（递归版）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;private static void quickSortByRecursive(int[] arr, int start, int end) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (start &amp;gt;= end) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int partIndex = partition(arr, start, end);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    quickSortByRecursive(arr, start, partIndex - 1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    quickSortByRecursive(arr, partIndex + 1, end);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  * 分区算法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;private static int partition(int[] arr, int start, int end) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (start &amp;lt; end) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        int pivot = arr[start];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        while (start &amp;lt; end) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            while (start &amp;lt; end &amp;amp;&amp;amp; arr[end] &amp;gt;= pivot) end--;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            arr[start] = arr[end];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            while (start &amp;lt; end &amp;amp;&amp;amp; arr[start] &amp;lt;= pivot) start++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            arr[end] = arr[start];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        arr[start] = pivot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return start;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;动图演示&quot;&gt;&lt;a href=&quot;#动图演示&quot; class=&quot;headerlink&quot; title=&quot;动图演示&quot;&gt;&lt;/a&gt;动图演示&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/hHPWj2c.gif&quot; alt&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://keep2iron.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>希尔排序 &amp; 归并排序</title>
    <link href="https://keep2iron.github.io/2019/03/28/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F&amp;%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <id>https://keep2iron.github.io/2019/03/28/希尔排序&amp;归并排序/</id>
    <published>2019-03-28T07:41:58.000Z</published>
    <updated>2019-03-28T08:20:31.175Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/I6WksMT.jpg" width="680px"></p><blockquote><p><a href="https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">维基百科-快速排序</a><br><a href="https://zh.wikipedia.org/wiki/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">维基百科-归并排序</a><br><a href="https://www.cnblogs.com/onepixel/articles/7674659.html" target="_blank" rel="noopener">cnblog-排序算法</a></p></blockquote><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><h4 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h4><p>希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。希尔排序是非稳定排序算法。</p><ul><li>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</li><li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率</li><li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位</li></ul><p><strong>步长</strong>的选择是希尔排序的重要部分。只要最终步长为1任何步长序列都可以工作。算法最开始以一定的步长进行排序。然后会继续以一定步长进行排序，最终算法以步长为1进行排序。当步长为1时，算法变为普通插入排序，这就保证了数据一定会被排序。</p><ul><li>取初始的步长为step(初始值为数组长度arr的一半)</li><li>以步长为单位 让arr[step] arr[step <em> 2] … arr[step </em> n]进行插入排序</li><li>步长进行除二直至步长单位为1时进行全数列的插入排序</li></ul><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public void shellSort(int[] arr)&#123;</span><br><span class="line">int step = maxSize / 2;</span><br><span class="line">while (step &gt;= 1) &#123;</span><br><span class="line">    for (int i = step; i &lt; arr.length; i += step) &#123;</span><br><span class="line">        int currentItem = arr[i];</span><br><span class="line">        int preIndex = i - step;</span><br><span class="line">        while (preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; currentItem) &#123;</span><br><span class="line">            arr[preIndex + step] = arr[preIndex];</span><br><span class="line">            preIndex -= step;</span><br><span class="line">        &#125;</span><br><span class="line">        if (preIndex + step != i) &#123;</span><br><span class="line">            arr[preIndex + step] = currentItem;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    step /= 2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h4 id="算法描述-1"><a href="#算法描述-1" class="headerlink" title="算法描述"></a>算法描述</h4><p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 </p><p>递归方案</p><ul><li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列</li><li>设定两个指针，最初位置分别为两个已经排序序列的起始位置</li><li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置</li><li>重复步骤3直到某一指针到达序列尾</li><li>将另一序列剩下的所有元素直接复制到合并序列尾</li></ul><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public static void mergeSort(int[] arr) &#123;</span><br><span class="line">    int[] result = new int[arr.length];</span><br><span class="line"></span><br><span class="line">    mergeSortRecursive(arr, result, 0, arr.length - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void mergeSortRecursive(int[] arr, int[] result, int start, int end) &#123;</span><br><span class="line">    if (start &gt;= end) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int length = end - start;</span><br><span class="line">    int mid = start + (length &gt;&gt; 2);</span><br><span class="line"></span><br><span class="line">    int start1 = start;</span><br><span class="line">    int start2 = mid + 1;</span><br><span class="line">    int end1 = mid;</span><br><span class="line">    int end2 = end;</span><br><span class="line"></span><br><span class="line">    mergeSortRecursive(arr, result, start1, end1);</span><br><span class="line">    mergeSortRecursive(arr, result, start2, end2);</span><br><span class="line"></span><br><span class="line">    int k = start;</span><br><span class="line"></span><br><span class="line">    while (start1 &lt;= end1 &amp;&amp; start2 &lt;= end2) &#123;</span><br><span class="line">        result[k++] = arr[start1] &gt; arr[start2] ? arr[start2++] : arr[start1++];</span><br><span class="line">    &#125;</span><br><span class="line">    while (start1 &lt;= end1) &#123;</span><br><span class="line">        result[k++] = arr[start1++];</span><br><span class="line">    &#125;</span><br><span class="line">    while (start2 &lt;= end2) &#123;</span><br><span class="line">        result[k++] = arr[start2++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = start; i &lt;= end; i++) &#123;</span><br><span class="line">        arr[i] = result[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="动图演示"><a href="#动图演示" class="headerlink" title="动图演示"></a>动图演示</h4><p><img src="https://i.imgur.com/9MhBXsA.gif" width="640px"><br><a id="more"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.imgur.com/I6WksMT.jpg&quot; width=&quot;680px&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;维基百科-快速排序&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;维基百科-归并排序&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.cnblogs.com/onepixel/articles/7674659.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;cnblog-排序算法&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;希尔排序&quot;&gt;&lt;a href=&quot;#希尔排序&quot; class=&quot;headerlink&quot; title=&quot;希尔排序&quot;&gt;&lt;/a&gt;希尔排序&lt;/h2&gt;&lt;h4 id=&quot;算法描述&quot;&gt;&lt;a href=&quot;#算法描述&quot; class=&quot;headerlink&quot; title=&quot;算法描述&quot;&gt;&lt;/a&gt;算法描述&lt;/h4&gt;&lt;p&gt;希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。希尔排序是非稳定排序算法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;希尔排序是基于插入排序的以下两点性质而提出改进方法的：&lt;/li&gt;
&lt;li&gt;插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率&lt;/li&gt;
&lt;li&gt;但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;步长&lt;/strong&gt;的选择是希尔排序的重要部分。只要最终步长为1任何步长序列都可以工作。算法最开始以一定的步长进行排序。然后会继续以一定步长进行排序，最终算法以步长为1进行排序。当步长为1时，算法变为普通插入排序，这就保证了数据一定会被排序。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;取初始的步长为step(初始值为数组长度arr的一半)&lt;/li&gt;
&lt;li&gt;以步长为单位 让arr[step] arr[step &lt;em&gt; 2] … arr[step &lt;/em&gt; n]进行插入排序&lt;/li&gt;
&lt;li&gt;步长进行除二直至步长单位为1时进行全数列的插入排序&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;代码实现&quot;&gt;&lt;a href=&quot;#代码实现&quot; class=&quot;headerlink&quot; title=&quot;代码实现&quot;&gt;&lt;/a&gt;代码实现&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public void shellSort(int[] arr)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	int step = maxSize / 2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	while (step &amp;gt;= 1) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	    for (int i = step; i &amp;lt; arr.length; i += step) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	        int currentItem = arr[i];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	        int preIndex = i - step;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	        while (preIndex &amp;gt;= 0 &amp;amp;&amp;amp; arr[preIndex] &amp;gt; currentItem) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	            arr[preIndex + step] = arr[preIndex];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	            preIndex -= step;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	        if (preIndex + step != i) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	            arr[preIndex + step] = currentItem;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	    step /= 2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;归并排序&quot;&gt;&lt;a href=&quot;#归并排序&quot; class=&quot;headerlink&quot; title=&quot;归并排序&quot;&gt;&lt;/a&gt;归并排序&lt;/h2&gt;&lt;h4 id=&quot;算法描述-1&quot;&gt;&lt;a href=&quot;#算法描述-1&quot; class=&quot;headerlink&quot; title=&quot;算法描述&quot;&gt;&lt;/a&gt;算法描述&lt;/h4&gt;&lt;p&gt;归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 &lt;/p&gt;
&lt;p&gt;递归方案&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列&lt;/li&gt;
&lt;li&gt;设定两个指针，最初位置分别为两个已经排序序列的起始位置&lt;/li&gt;
&lt;li&gt;比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置&lt;/li&gt;
&lt;li&gt;重复步骤3直到某一指针到达序列尾&lt;/li&gt;
&lt;li&gt;将另一序列剩下的所有元素直接复制到合并序列尾&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;代码实现-1&quot;&gt;&lt;a href=&quot;#代码实现-1&quot; class=&quot;headerlink&quot; title=&quot;代码实现&quot;&gt;&lt;/a&gt;代码实现&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public static void mergeSort(int[] arr) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int[] result = new int[arr.length];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mergeSortRecursive(arr, result, 0, arr.length - 1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public static void mergeSortRecursive(int[] arr, int[] result, int start, int end) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (start &amp;gt;= end) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int length = end - start;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int mid = start + (length &amp;gt;&amp;gt; 2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int start1 = start;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int start2 = mid + 1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int end1 = mid;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int end2 = end;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mergeSortRecursive(arr, result, start1, end1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mergeSortRecursive(arr, result, start2, end2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int k = start;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    while (start1 &amp;lt;= end1 &amp;amp;&amp;amp; start2 &amp;lt;= end2) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        result[k++] = arr[start1] &amp;gt; arr[start2] ? arr[start2++] : arr[start1++];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    while (start1 &amp;lt;= end1) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        result[k++] = arr[start1++];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    while (start2 &amp;lt;= end2) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        result[k++] = arr[start2++];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    for (int i = start; i &amp;lt;= end; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        arr[i] = result[i];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;动图演示&quot;&gt;&lt;a href=&quot;#动图演示&quot; class=&quot;headerlink&quot; title=&quot;动图演示&quot;&gt;&lt;/a&gt;动图演示&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/9MhBXsA.gif&quot; width=&quot;640px&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://keep2iron.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>插入排序 &amp; 选择排序</title>
    <link href="https://keep2iron.github.io/2019/03/28/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F&amp;%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    <id>https://keep2iron.github.io/2019/03/28/选择排序&amp;插入排序/</id>
    <published>2019-03-28T07:41:58.000Z</published>
    <updated>2019-03-28T08:20:35.855Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/I6WksMT.jpg" width="680px"></p><blockquote><p><a href="https://www.cnblogs.com/onepixel/articles/7674659.html" target="_blank" rel="noopener">cnblog-排序算法</a></p></blockquote><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>顾名思义选择最值（最大或者最小值）存放到排序数列的起始位置，然后在剩余数列中寻找最值，然后将其放到已排序数列的末尾。以此类推，直到所有元素排序完毕。</p><h4 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h4><p><strong> 通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。跟选择排序的不同点是插入排序时向前搜索，而选择排序是向后搜索 </strong></p><ul><li>初始状态：无序区为R[1..n]，有序区为空；</li><li>第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</li><li>n-1趟结束，数组有序化了。</li></ul><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static void selectionSort(int[]arr)&#123;</span><br><span class="line">for (int i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">int maxIndex = i;</span><br><span class="line">for (int j = i + 1; j &lt; arr.length; j++) &#123;</span><br><span class="line">    if (arr[maxIndex] &lt; arr[j]) &#123;</span><br><span class="line">        maxIndex = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">if (maxIndex != i) &#123;</span><br><span class="line">    int temp = arr[maxIndex];</span><br><span class="line">    arr[maxIndex] = arr[i];</span><br><span class="line">    arr[i] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="动图演示"><a href="#动图演示" class="headerlink" title="动图演示"></a>动图演示</h4><p><img src="https://i.imgur.com/9Yl8LqY.gif" alt></p><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h4 id="算法描述-1"><a href="#算法描述-1" class="headerlink" title="算法描述"></a>算法描述</h4><p>它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。可以想象手中的扑克牌的排序。</p><ul><li>从第一个元素开始，可以认为该元素是已经排序过的</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描</li><li>如果元素大于（小于）新元素，则交换位置</li><li>重复交换 直至 新元素在已排序数列中达到有序的位置上</li><li>重复 2 ~ 5步骤</li></ul><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public void insertSort(int[] arr)&#123;</span><br><span class="line">for (int i = 1; i &lt; arr.length; i++) &#123;</span><br><span class="line">    int temp = arr[i];</span><br><span class="line">    int preIndex = i - 1;</span><br><span class="line">    while (preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; temp) &#123;</span><br><span class="line">        arr[preIndex + 1] = arr[preIndex];</span><br><span class="line">        preIndex--;</span><br><span class="line">    &#125;</span><br><span class="line">    if (preIndex + 1 != i - 1) &#123;</span><br><span class="line">        arr[preIndex + 1] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="动图演示-1"><a href="#动图演示-1" class="headerlink" title="动图演示"></a>动图演示</h4><p><img src="https://i.imgur.com/2oLvWw7.gif" width="640px"><br><a id="more"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.imgur.com/I6WksMT.jpg&quot; width=&quot;680px&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/onepixel/articles/7674659.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;cnblog-排序算法&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;选择排序&quot;&gt;&lt;a href=&quot;#选择排序&quot; class=&quot;headerlink&quot; title=&quot;选择排序&quot;&gt;&lt;/a&gt;选择排序&lt;/h2&gt;&lt;p&gt;顾名思义选择最值（最大或者最小值）存放到排序数列的起始位置，然后在剩余数列中寻找最值，然后将其放到已排序数列的末尾。以此类推，直到所有元素排序完毕。&lt;/p&gt;
&lt;h4 id=&quot;算法描述&quot;&gt;&lt;a href=&quot;#算法描述&quot; class=&quot;headerlink&quot; title=&quot;算法描述&quot;&gt;&lt;/a&gt;算法描述&lt;/h4&gt;&lt;p&gt;&lt;strong&gt; 通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。跟选择排序的不同点是插入排序时向前搜索，而选择排序是向后搜索 &lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;初始状态：无序区为R[1..n]，有序区为空；&lt;/li&gt;
&lt;li&gt;第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；&lt;/li&gt;
&lt;li&gt;n-1趟结束，数组有序化了。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;代码实现&quot;&gt;&lt;a href=&quot;#代码实现&quot; class=&quot;headerlink&quot; title=&quot;代码实现&quot;&gt;&lt;/a&gt;代码实现&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public static void selectionSort(int[]arr)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	for (int i = 0; i &amp;lt; arr.length; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		int maxIndex = i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		for (int j = i + 1; j &amp;lt; arr.length; j++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		    if (arr[maxIndex] &amp;lt; arr[j]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		        maxIndex = j;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		if (maxIndex != i) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		    int temp = arr[maxIndex];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		    arr[maxIndex] = arr[i];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		    arr[i] = temp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;动图演示&quot;&gt;&lt;a href=&quot;#动图演示&quot; class=&quot;headerlink&quot; title=&quot;动图演示&quot;&gt;&lt;/a&gt;动图演示&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/9Yl8LqY.gif&quot; alt&gt;&lt;/p&gt;
&lt;h2 id=&quot;插入排序&quot;&gt;&lt;a href=&quot;#插入排序&quot; class=&quot;headerlink&quot; title=&quot;插入排序&quot;&gt;&lt;/a&gt;插入排序&lt;/h2&gt;&lt;h4 id=&quot;算法描述-1&quot;&gt;&lt;a href=&quot;#算法描述-1&quot; class=&quot;headerlink&quot; title=&quot;算法描述&quot;&gt;&lt;/a&gt;算法描述&lt;/h4&gt;&lt;p&gt;它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。可以想象手中的扑克牌的排序。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从第一个元素开始，可以认为该元素是已经排序过的&lt;/li&gt;
&lt;li&gt;取出下一个元素，在已经排序的元素序列中从后向前扫描&lt;/li&gt;
&lt;li&gt;如果元素大于（小于）新元素，则交换位置&lt;/li&gt;
&lt;li&gt;重复交换 直至 新元素在已排序数列中达到有序的位置上&lt;/li&gt;
&lt;li&gt;重复 2 ~ 5步骤&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;代码实现-1&quot;&gt;&lt;a href=&quot;#代码实现-1&quot; class=&quot;headerlink&quot; title=&quot;代码实现&quot;&gt;&lt;/a&gt;代码实现&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public void insertSort(int[] arr)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	for (int i = 1; i &amp;lt; arr.length; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	    int temp = arr[i];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	    int preIndex = i - 1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	    while (preIndex &amp;gt;= 0 &amp;amp;&amp;amp; arr[preIndex] &amp;gt; temp) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	        arr[preIndex + 1] = arr[preIndex];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	        preIndex--;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	    if (preIndex + 1 != i - 1) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	        arr[preIndex + 1] = temp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;动图演示-1&quot;&gt;&lt;a href=&quot;#动图演示-1&quot; class=&quot;headerlink&quot; title=&quot;动图演示&quot;&gt;&lt;/a&gt;动图演示&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/2oLvWw7.gif&quot; width=&quot;640px&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://keep2iron.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>React-Native状态管理框架mobx实战</title>
    <link href="https://keep2iron.github.io/2018/11/06/React-Native%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E6%A1%86%E6%9E%B6mobx/"/>
    <id>https://keep2iron.github.io/2018/11/06/React-Native状态管理框架mobx/</id>
    <published>2018-11-06T03:00:34.000Z</published>
    <updated>2019-03-28T08:22:38.955Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cn.mobx.js.org/flow.png" width="680px"></p><blockquote><p>文章中的代码基于 ract-native 0.57.1编写</p></blockquote><p><a href="https://cn.mobx.js.org/" target="_blank" rel="noopener">MobX</a> 是一个经过战火洗礼的库，它通过透明的函数响应式编程(transparently applying functional reactive programming - TFRP)使得状态管理变得简单和可扩展。MobX背后的哲学很简单:</p><p><em>任何源自应用状态的东西都应该自动地获得。</em></p><a id="more"></a><p>上面提到了一个重要的关键点 <a href="https://zh.wikipedia.org/wiki/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B" target="_blank" rel="noopener"><em>响应式编程</em></a>。</p><h4>响应式编程</h4><ul><li><p>面向数据</p></li><li><p>计算模型会自动将变化的值通过数据流进行传播</p></li></ul><p>mobx充分体现了上面提到的这两点，那么接下来的问题是….</p><h4>如何上手mobx？</h4><h5 id="Observable-可观察的状态"><a href="#Observable-可观察的状态" class="headerlink" title="Observable(可观察的状态)"></a>Observable(可观察的状态)</h5><p>该类用于修饰类成员变量（实例）即可完成可观察的功能。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">ES Next(装饰器)语法:</span><br><span class="line"></span><br><span class="line">import &#123; observable &#125; from &quot;mobx&quot;;</span><br><span class="line"></span><br><span class="line">class Todo &#123;</span><br><span class="line">    id = Math.random();</span><br><span class="line">    @observable title = &quot;&quot;;</span><br><span class="line">    @observable finished = false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ES5</span><br><span class="line">import &#123; decorate, observable &#125; from &quot;mobx&quot;;</span><br><span class="line"></span><br><span class="line">class Todo &#123;</span><br><span class="line">    id = Math.random();</span><br><span class="line">    title = &quot;&quot;;</span><br><span class="line">    finished = false;</span><br><span class="line">&#125;</span><br><span class="line">decorate(Todo, &#123;</span><br><span class="line">    title: observable,</span><br><span class="line">    finished: observable</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h5 id="Computed-values-计算值"><a href="#Computed-values-计算值" class="headerlink" title="Computed values(计算值)"></a>Computed values(计算值)</h5><p>刚开始接触mobx的时候我并没有认为这个计算有什么意义，不过随着接触的深入发现这个概念也是一个极其重要的概念。<br>例如需求如下：购物车中有一个显示购物车数量的按钮，通过前面的装饰器我们很容易编写出表示购物车列表的state数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@observable shoppingCart = [];</span><br></pre></td></tr></table></figure><p>那么我们还需要知道购物车的数量，你可能会说通过shoppingCart.length获取。但是list是会实时改变的，那么如何不做到利用另外一个变量的情况下获取购物车的数量呢？请看如下代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@computed</span><br><span class="line">getShoppingCartCount()&#123;</span><br><span class="line">return this.shoppingCart.length; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当添加了一个shoppingCart或者其属性发生变化时，MobX 会确保 shoppingCart 自动更新。 像这样的计算可以类似于 MS Excel 这样电子表格程序中的公式。每当只有在需要它们的时候，它们才会自动更新。</p><h5 id="observer（观察者）、Action"><a href="#observer（观察者）、Action" class="headerlink" title="observer（观察者）、Action"></a>observer（观察者）、Action</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">// ShoppingCartStore.js</span><br><span class="line">export default class ShoppingCartStore &#123;</span><br><span class="line">    // 购物车列表</span><br><span class="line">    @observable</span><br><span class="line">    _shoppingCartList: Array&lt;ShoppingCartProduct&gt; = [];</span><br><span class="line"></span><br><span class="line">    @computed</span><br><span class="line">    get shoppingCartCount() &#123;</span><br><span class="line">        return this.shoppingCartList.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @action</span><br><span class="line">    async loadShoppingCarts() &#123;</span><br><span class="line">        const resp = await this.respitory.loadShoppingCart();</span><br><span class="line">        if (resp) &#123;</span><br><span class="line">            runInAction(() =&gt; &#123;</span><br><span class="line">                this._shoppingCartList = resp.list;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ShoppingCartPage.js</span><br><span class="line">@observer</span><br><span class="line">export default class ShoppingCartPage extends Component&lt;Props, State&gt; &#123;</span><br><span class="line"></span><br><span class="line">componentDidMount()&#123;</span><br><span class="line">const &#123; shoppingCartStore &#125; = this.props;</span><br><span class="line"> </span><br><span class="line">shoppingCartStore.loadShoppingCarts().catch(() =&gt; &#123;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">render()&#123;</span><br><span class="line">return (</span><br><span class="line">&lt;FlatList</span><br><span class="line">...//此处省略若干代码</span><br><span class="line">                data=&#123;this.store.shoppingCartList&#125;</span><br><span class="line">            /&gt;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码算是一个完整的购物车列表显示流程<br>1.由componentDidiMount触发store加载函数loadShoppingCarts,通过<em>this.respitory.loadShoppingCart</em>获取返回的数据，随后执行this._shoppingCartList = resp.list;那么为什么要写runInAction呢？<br>因为针对所有@observable的赋值操作必须在@action注解的函数或者在runInAction中执行。</p><blockquote><p>状态(这里就是_shoppingCartList)应该以某种方式来更新。<br>当状态更新后，MobX 会以一种高效且无障碍的方式处理好剩下的事情。像上面如此简单的语句，已经足够用来自动更新用户界面了。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cn.mobx.js.org/flow.png&quot; width=&quot;680px&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;文章中的代码基于 ract-native 0.57.1编写&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://cn.mobx.js.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MobX&lt;/a&gt; 是一个经过战火洗礼的库，它通过透明的函数响应式编程(transparently applying functional reactive programming - TFRP)使得状态管理变得简单和可扩展。MobX背后的哲学很简单:&lt;/p&gt;
&lt;p&gt;&lt;em&gt;任何源自应用状态的东西都应该自动地获得。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="react native" scheme="https://keep2iron.github.io/tags/react-native/"/>
    
  </entry>
  
  <entry>
    <title>React-Native原理的简单讨论</title>
    <link href="https://keep2iron.github.io/2018/11/04/React-Native%E7%AE%80%E5%8D%95%E5%8E%9F%E7%90%86%E8%AE%A8%E8%AE%BA/"/>
    <id>https://keep2iron.github.io/2018/11/04/React-Native简单原理讨论/</id>
    <published>2018-11-04T01:46:34.000Z</published>
    <updated>2018-11-06T03:05:29.861Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>文章中的代码基于 ract-native 0.57.1进行编写</p></blockquote><p><img src="https://i.imgur.com/wdMolXp.png" width="680px"></p><h4>Android</h4><ul><li><p>interface ReactApplication<br>该类用于获取一个默认的ReactHost实例对象</p></li><li><p>class ReactHost<br>包含ReactInstanceManager对象的一个简单的类</p></li><li><p><strong>class ReactInstanceManager</strong><br>该类用于管理CatalystInstance实力对象，配合ReactRootView管理View的创建与生命周期等功能。</p></li><li><p><strong>class ReactRootView</strong><br>ReactRootView是Catalyst的主视图，提供侦听大小更改的功能，以便UI管理器可以重新布局其元素。它委托处理自身和子视图的触摸事件，并使用JSTouchDispatcher将这些事件发送给JS。</p></li><li><p><strong>class CatalystInstance</strong><br>用于js与原生之间的通信管理类</p></li><li><p><strong>JavaScriptModule/NativeModule</strong><br>JavaScriptModule是JS Module，负责JS到Java的映射调用格式声明，由CatalystInstance统一管理。<br>NativeModule是ava Module，负责Java到Js的映射调用格式声明，由CatalystInstance统一管理。<br>AppRegistry、DeviceEventEmitter通过继承JavaScriptModule，然后声明相关方法即可调用。例如通过reactContext.getJSModule AppRegistry.class 方法获取AppRegistry对象即可调用js端暴露的方法。通过继承NativeModule然后编写方法并添加<strong>@ReactMethod</strong>注解即从native端暴露给js端调用。</p><a id="more"></a></li></ul><p></p><h4>React-Native是如何将一个jsx元素映射为一个原生控件的？</h4><br>1.加载<img src="https://i.imgur.com/j3ei8P8.png" width="680px"><br>2.渲染<img src="https://i.imgur.com/hlhPWSA.png" width="680px"><p></p><p></p><h4>渲染原理</h4><p></p><blockquote><p>编写jsx通过babel转换成标准js代码，通过createElement创建element</p></blockquote><blockquote><p>UIManager.js通过cpp端传递事件给Native端（Android/Ios）,利用了UIManagerModule.java中的createView、updateView、manageChildren等方法进行界面中元素的修改</p></blockquote><blockquote><p>UIManagerModule负责从js传递来的修改element元素的这些操作封装成事件，并添加到队列中，最终完成渲染</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;文章中的代码基于 ract-native 0.57.1进行编写&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/wdMolXp.png&quot; width=&quot;680px&quot;&gt;&lt;/p&gt;
&lt;h4&gt;Android&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;interface ReactApplication&lt;br&gt;该类用于获取一个默认的ReactHost实例对象&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;class ReactHost&lt;br&gt;包含ReactInstanceManager对象的一个简单的类&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;class ReactInstanceManager&lt;/strong&gt;&lt;br&gt;该类用于管理CatalystInstance实力对象，配合ReactRootView管理View的创建与生命周期等功能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;class ReactRootView&lt;/strong&gt;&lt;br&gt;ReactRootView是Catalyst的主视图，提供侦听大小更改的功能，以便UI管理器可以重新布局其元素。它委托处理自身和子视图的触摸事件，并使用JSTouchDispatcher将这些事件发送给JS。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;class CatalystInstance&lt;/strong&gt;&lt;br&gt;用于js与原生之间的通信管理类&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;JavaScriptModule/NativeModule&lt;/strong&gt;&lt;br&gt;JavaScriptModule是JS Module，负责JS到Java的映射调用格式声明，由CatalystInstance统一管理。&lt;br&gt;NativeModule是ava Module，负责Java到Js的映射调用格式声明，由CatalystInstance统一管理。&lt;br&gt;AppRegistry、DeviceEventEmitter通过继承JavaScriptModule，然后声明相关方法即可调用。例如通过reactContext.getJSModule AppRegistry.class 方法获取AppRegistry对象即可调用js端暴露的方法。通过继承NativeModule然后编写方法并添加&lt;strong&gt;@ReactMethod&lt;/strong&gt;注解即从native端暴露给js端调用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="react native" scheme="https://keep2iron.github.io/tags/react-native/"/>
    
  </entry>
  
  <entry>
    <title>React-Native跨平台技术选型</title>
    <link href="https://keep2iron.github.io/2018/11/03/React-Native%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/"/>
    <id>https://keep2iron.github.io/2018/11/03/React-Native跨平台技术选型/</id>
    <published>2018-11-03T07:46:34.000Z</published>
    <updated>2018-11-06T03:07:02.818Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/wdMolXp.png" width="680px"></p><h1 id="跨平台技术选型"><a href="#跨平台技术选型" class="headerlink" title="跨平台技术选型"></a>跨平台技术选型</h1><h4>React-Native的优势</h4><ul><li><p><strong>某些方面上开发效率高</strong> 在某些方面React Native开发效率比原生效率高，这里指的是开发效率，因为HotReload的关系，因此在开发React Native的时候基本上不用重新编译整个工程，这一点我认为对开发者的开发体验来说是非常棒的，在这里我指的是某些方面，当然什么方面来说的话后面会详细的进行展开。</p></li><li><p><strong>复杂的布局也能得心应手。</strong> Flex布局针对于复杂页面的布局很有优势，由于之前是做安卓开发，比如安卓在开发流式布局或者自定义多样化的布局上需要进行<strong>自定义View</strong>，如果考虑性能可能还需要进行使用RecyclerView进行多布局。因此结合css position属性 + flex可以轻松应对大多数场景了。</p></li><li><p><strong>开发效率快。</strong> 由于js是弱类型语言，在ReactNative中使用了基于es6的语法，因此可以大大提高了js面向对象的编程的能力。而且语法糖丰富，第三方扩展多，使用npm基本上什么库都能够找到你想要的第三方库</p></li><li><p><strong>learn once write everywhere!!</strong> 这里的优势确实还是有的，由于之前确实学习过一段时间的React，对于React的这套体系(更改State驱动界面更新，Props可以用来跨组件传值等等)这些在React编程的思路确实是没有变化的，因此前端对于转来学习React Native应该是问题不大的。</p></li><li><p><strong>跨平台</strong> 这一点恐怕是选择React Native的一个非常重要的原因。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">--------------js--------------</span><br><span class="line">              ||</span><br><span class="line">              \/</span><br><span class="line">----------js runtime----------</span><br><span class="line">           ||    /\</span><br><span class="line">           \/    ||</span><br><span class="line">------Android/IOS render------</span><br></pre></td></tr></table></figure></li></ul><a id="more"></a><h4>React-Native不足</h4><ul><li><p><strong>React Native更新太快</strong> 通常我们说软件更新快是一件好事情，但是对于咱们开发React Native来说的话确实有点….(学不动.png)，更新太快会有一些库的兼容问题，因此很可能半年之前写的项目不能很好的运行在最新的React Native的版本之上。（相信React Native后面能够稳定下来）</p></li><li><p><strong>第三方库的质量问题</strong> 本着不重复造轮子的原则，我们一般都会或多或少的引入第三方库。对于React Native来说的话确实优秀的第三方库太少了，一般很难满足自己的需求，因此只能读其代码进行定制化的改造。这一点也确实是由于精通Android 和ios以及Rn的开发者比较少，很少能够进行全面的编写完美的跨平台组件。（基于稳定下来之后，我想这个问题也能够得到充分的解决）</p></li><li><p><strong>React Native稀奇古怪的问题还是不少</strong> 这一点上主要在于刚刚接触React Native的时候对于语法以及开发项目的不理解时导致的问题挺多的。（没办法只能说坑踩的多了，你就是大佬了）</p></li><li><p><strong>成也js败也js</strong> 这一点只能代表我个人观点，js的动态能力很强，在代码的编写上可以说是每一个人都有心中自己的最佳实践。（当然了客观上我们还是需要多学习像airbnb等这些大公司编写的优秀的代码）在js中，当我们要调用别人的库的时候我们只能够进行查找文档或者找到对应的博客进行学习。对于我这种从java转过来的编程者更倾向于希望阅读代码的api注释以及传入参数的限制等等，这样的话对于开发效率的提升也是不小的，而且可以更快的上手。（不过对于js这种动态类型来说，TypeScript（它不是一个库，应该说是js的另外一种生态了）、Flow这种可以帮助js进行类型检查的库或者生态能够更好的解决这个问题了）</p></li></ul><h4>Weex OR Flutter</h4><ul><li><p>Weex是阿里巴巴基于React-Native的灵感从而产生的项目,Weex利用了v8来作为js runtime并且使用vue作为开发框架，这对于vue的使用者来说是一个很好的消息。</p></li><li><p>Flutter是Google推出的一个跨平台框架，使用Skia作为绘制引擎。由于IOS并无内置该代码，因此IOS安装体积会比安卓大。与RN和Weex不同，Flutter并不是通过解析js代码转换Native代码渲染而是相当于使用了一个Canvas使用Skia进行绘制，由于RN目前已知的一些问题我认为Flutter可能是未来跨平台的一种重要的解决方案。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.imgur.com/wdMolXp.png&quot; width=&quot;680px&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;跨平台技术选型&quot;&gt;&lt;a href=&quot;#跨平台技术选型&quot; class=&quot;headerlink&quot; title=&quot;跨平台技术选型&quot;&gt;&lt;/a&gt;跨平台技术选型&lt;/h1&gt;&lt;h4&gt;React-Native的优势&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;某些方面上开发效率高&lt;/strong&gt; 在某些方面React Native开发效率比原生效率高，这里指的是开发效率，因为HotReload的关系，因此在开发React Native的时候基本上不用重新编译整个工程，这一点我认为对开发者的开发体验来说是非常棒的，在这里我指的是某些方面，当然什么方面来说的话后面会详细的进行展开。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;复杂的布局也能得心应手。&lt;/strong&gt; Flex布局针对于复杂页面的布局很有优势，由于之前是做安卓开发，比如安卓在开发流式布局或者自定义多样化的布局上需要进行&lt;strong&gt;自定义View&lt;/strong&gt;，如果考虑性能可能还需要进行使用RecyclerView进行多布局。因此结合css position属性 + flex可以轻松应对大多数场景了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;开发效率快。&lt;/strong&gt; 由于js是弱类型语言，在ReactNative中使用了基于es6的语法，因此可以大大提高了js面向对象的编程的能力。而且语法糖丰富，第三方扩展多，使用npm基本上什么库都能够找到你想要的第三方库&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;learn once write everywhere!!&lt;/strong&gt; 这里的优势确实还是有的，由于之前确实学习过一段时间的React，对于React的这套体系(更改State驱动界面更新，Props可以用来跨组件传值等等)这些在React编程的思路确实是没有变化的，因此前端对于转来学习React Native应该是问题不大的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;跨平台&lt;/strong&gt; 这一点恐怕是选择React Native的一个非常重要的原因。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;--------------js--------------&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              ||&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              \/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;----------js runtime----------&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           ||    /\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           \/    ||&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;------Android/IOS render------&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="react native" scheme="https://keep2iron.github.io/tags/react-native/"/>
    
  </entry>
  
  <entry>
    <title>大话自定义view(1)</title>
    <link href="https://keep2iron.github.io/2018/08/19/%E5%A4%A7%E8%AF%9D%E8%87%AA%E5%AE%9A%E4%B9%89view(%E4%B8%80)/"/>
    <id>https://keep2iron.github.io/2018/08/19/大话自定义view(一)/</id>
    <published>2018-08-19T12:33:00.000Z</published>
    <updated>2018-08-21T16:39:24.075Z</updated>
    
    <content type="html"><![CDATA[<h5>出师不利</h5><p>小艾从新兵训练营毕业，在训练营中学习不少编程方面的知识，学着编写了不少Android方面的小程序，他踌躇满志一心想要报考<em>Android调查兵团</em>。终于当投递了无数次申请了之后，调查兵团准许了小艾的申请，并给与了他一次面试的机会。</p><p>到了要进行面试的日子，考官发放了一个题目，上面写道：“<strong>请编写一个如下图的自定义控件</strong>”</p><p><img src="https://i.imgur.com/X1ZyPpl.png" alt="pic1"></p><a id="more"></a><p>小艾心想糟了，身上这一身本事都是CV老师教的(PS:老夫敲代码就是一梭子.png)，自己写这自定义控件还真的是不太行阿~。小艾心灰意冷的答完了题目，垂头丧一些气的回到了自己的房间，痛定思痛心想：这自定义控件劳资一定要攻破它，说着小艾就打开了aoogle搜索了一下这自定义控件的一些知识。</p><p></p><h5>奇怪的Constructor</h5>小艾：哦，这第一步原来是要继承一个View或者一个ViewGroup​，我这个自定义控件是一个圆形进度条，那么我就起名叫<strong>CircleProgressView</strong>吧！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CircleProgress</span> <span class="keyword">extends</span> <span class="title">View</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">CircleProgress</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>(context, <span class="keyword">null</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//@Nullable是android扩展包的注解，标识这个变量是可以为null的</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">CircleProgress</span><span class="params">(Context context, @Nullable AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>(context, attrs, <span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">CircleProgress</span><span class="params">(Context context, @Nullable AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>可是这自定义View为啥要重写了这三个方法呢？小艾这是产生了一个疑惑，不过正好今天是一个星期六，大表哥正好来小艾家玩，心里正犯嘀咕。大表哥看了一眼代码，瞅了一眼犯嘀咕的小艾。</p><p>大表哥：”小艾呀，我知道你心中为啥这么困惑。首先第一个方法<em>CircleProgress(Context)</em>是保证了我们能够<strong>直接创建一个自定义控件</strong>因此才有了第一个构造方法。第二个方法的带了一个<strong>AttributeSet</strong>，这个方法是为了Android中使用<strong>Pull解析</strong>xml时，解析之后的属性便全部都放入了这个对象中，简单点说就是为了<strong>提供给xml解析时调用</strong>。第三个方法嘛，说来安卓真的是为我们开发者操碎了心，第三个参数用于解析主题文件时能够产生不同属性值，因此才有了这第三个参数。”</p><blockquote><p>在第一种new出来的生成方式的时候，会调用一个参数的构造方法。</p></blockquote><blockquote><p>第二种使用xml声明的方式则会调用两个参数的构造方法</p></blockquote><blockquote><p>第三个参数的意义在于在当前主题中包含了style资源的一个属性值，适用于对于当前view的一个默认style。 需要特别指出的是三个参数的构造方法系统是不进行调用的，需要我们这里显式的进行调用，比如我们的Button通过调用，并传递了com.android.internal.R.attr.buttonStyle，而在4.4的主题文件是holo风格，然后定义了button的默认的几个属性</p></blockquote><p>以Button为例下面，是Button的构造方法以及style文件中的声明。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Button</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>(context, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Button</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>(context, attrs, com.android.internal.R.attr.buttonStyle);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Button</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyle)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(context, attrs, defStyle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"Theme.DeviceDefault"</span> <span class="attr">parent</span>=<span class="string">"Theme.Holo"</span> &gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">...</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"buttonStyle"</span>&gt;</span>@android:style/Widget.DeviceDefault.Button<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="undefined">....</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"Widget.DeviceDefault.Button"</span> <span class="attr">parent</span>=<span class="string">"Widget.Holo.Button"</span> &gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"Widget.Holo.Button"</span> <span class="attr">parent</span>=<span class="string">"Widget.Button"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:background"</span>&gt;</span>@android:drawable/btn_default_holo_dark<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:textAppearance"</span>&gt;</span>?android:attr/textAppearanceMedium<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:textColor"</span>&gt;</span>@android:color/primary_text_holo_dark<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:minHeight"</span>&gt;</span>48dip<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:minWidth"</span>&gt;</span>64dip<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><h5>懵逼的onMeasure</h5>大表哥：言归正传，以上就是构造函数的一些意义啦，这些东西多结合实战才会有进步~！当然了理解constructor的过程还是第一步，后面还有你好看的呢~！来看一下这个函数。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line"><span class="comment">//获取测量的宽度和高度</span></span><br><span class="line"><span class="keyword">int</span> widthSize = getMeasureSize(widthMeasureSpec);</span><br><span class="line"><span class="keyword">int</span> heightSize = getMeasureSize(heightMeasureSpec);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> size = widthSize &gt; heightSize ? heightSize : widthSize;</span><br><span class="line"><span class="comment">//必须调用这个方法，进行设置大小</span></span><br><span class="line">setMeasuredDimension(size,size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getMeasureSize</span><span class="params">(<span class="keyword">int</span> measureSpec)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> mode = MeasureSpec.getMode(measureSpec);</span><br><span class="line"><span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span>(mode)&#123;</span><br><span class="line"><span class="keyword">case</span> MeasureSpec.EXACTLY:</span><br><span class="line"><span class="keyword">case</span> MeasureSpec.AT_MOST:</span><br><span class="line">size = MeasureSpec.getSize(measureSpec);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</span><br><span class="line">size = CommonUtil.dp2px(getContext(),<span class="number">50</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//决定了我们自己的控件相对与父控件的位置</span></span><br><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.onLayout(changed, left, top, right, bottom);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>小艾：哇，这个函数干啥玩意的咋越看越懵逼呢！！<br>大表哥：哈哈，懵逼吧~，不过我先跟你阐述几个概念，这几个概念你心里有个数，后面不会再查文档就行了。</p><p><strong>EXACTLY</strong></p><p>表示父视图希望子视图的大小应该是由specSize的值来决定的，系统默认会按照这个规则来设置子视图的大小，开发人员当然也可以按照自己的意愿设置成任意的大小。</p><p><strong>AT_MOST</strong></p><p>表示子视图最多只能是specSize中指定的大小，开发人员应该尽可能小得去设置这个视图，并且保证不会超过specSize。系统默认会按照这个规则来设置子视图的大小，开发人员当然也可以按照自己的意愿设置成任意的大小。</p><p><strong>UNSPECIFIED</strong></p><p>表示开发人员可以将视图按照自己的意愿设置成任意的大小，没有任何限制。这种情况比较少见，不太会用到。</p><blockquote><p>上面的一些表述参考了郭霖的<a href="http://blog.csdn.net/guolin_blog/article/details/16330267" target="_blank" rel="noopener">博客</a></p></blockquote><p></p><h5>一些基本的操作</h5><br>大表哥：今天主要是画这个进度是吧，既然要画东西（Canvas），起码我们是必须要有一个笔的，在Android中有个类叫<strong>Paint</strong>，你去官方文档看下它这个相关的api做一些demo基本上就能够上手啦~！当然我们这里再来说说获取了画笔之后，一些关于自定义控件的基本操作。有几点是要确定的<br><strong>1.绘制区域的大小（主要跟控件的大小有关）</strong><br>小艾：立方懵逼.png…….<br>大表哥：一般我觉得写自定义控件来说，获取他的大小基本上必不可少，那么在什么函数获取大小比较合适呢？我个人认为在onSizeChanged(int w, int h, int oldw, int oldh) 这个方法中进行赋值大小比较合适。虽然onDraw可以获取但是onDraw会可能会调用多次，书写一些初始化操作就不太合适了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onSizeChanged</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">int</span> oldw, <span class="keyword">int</span> oldh)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.onSizeChanged(w, h, oldw, oldh);</span><br><span class="line"><span class="comment">//初始化画笔的宽度</span></span><br><span class="line"><span class="keyword">int</span> strokeSize = (<span class="keyword">int</span>) (getMeasuredWidth() / <span class="number">2</span> * <span class="number">0.3f</span>);</span><br><span class="line"><span class="keyword">int</span> size = <span class="number">10</span> + strokeSize;</span><br><span class="line"><span class="comment">//初始化绘制区域</span></span><br><span class="line">mDrawRect = <span class="keyword">new</span> RectF(getPaddingLeft() + size,getPaddingTop() + size,getWidth() -getPaddingLeft() - size,getHeight() - getPaddingBottom() - size);</span><br><span class="line">mPaint.setStrokeWidth(strokeSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p></p><h5>干活啦！气氛搞起来~</h5><br>大表哥：终于到了你应该最感兴趣的代码了，这里来说说绘制的流程<p></p><ol><li><p><strong>canvas.save()</strong>这里主要为了保存画布的状态，因为后面可能还需要针对画布进行旋转、平移、缩放等等操作。</p></li><li><p><strong>canvas.ratate/translate/scale</strong>这里是针对画布进行平移缩放，当然了画布的坐标系也会同步修改。</p></li><li><strong>canvas.draw</strong>这里就是干活的地方，发挥你灵魂画师的基本功力，在这里可以为所欲为的画你想画的东西。</li><li><strong>canvas.restore()</strong>切记如果你之前<strong>save过画布之后，一定要restore！！</strong>,你也不想后面画着其他图形的时候犯嘀咕，咦？我这矩形咋飞上了天？？明明就是居中的阿~~。<strong>主要就是恢复save时canvas的坐标系</strong>。</li></ol><p>下面就是一个代码实例，小艾你就跟着多练习啦，下午有个大保健等着我，溜了溜了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line"><span class="comment">//保存画布的当前状态</span></span><br><span class="line">canvas.save();</span><br><span class="line"><span class="comment">//旋转画布逆时针90°，那么坐标系就发生了旋转了。</span></span><br><span class="line">canvas.rotate(-<span class="number">90</span>,mDrawRect.centerX(),mDrawRect.centerY());</span><br><span class="line"><span class="comment">//设置背景圆的颜色</span></span><br><span class="line">mPaint.setColor(mDefColor);</span><br><span class="line">canvas.drawCircle(mDrawRect.centerX(),mDrawRect.centerY(),mDrawRect.width() / <span class="number">2</span>,mPaint);</span><br><span class="line"><span class="comment">//设置弧线的颜色</span></span><br><span class="line">mPaint.setColor(mColor);</span><br><span class="line">canvas.drawArc(mDrawRect,<span class="number">0</span>,mProgress * <span class="number">360</span>,<span class="keyword">false</span>,mPaint);</span><br><span class="line"><span class="comment">//重新恢复画布</span></span><br><span class="line">canvas.restore();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>小艾：留下了没技术的泪水.png~~~</p><p>自定义控件系列还在持续连载中!!!!coming soon</p>]]></content>
    
    <summary type="html">
    
      &lt;h5&gt;出师不利&lt;/h5&gt;

&lt;p&gt;小艾从新兵训练营毕业，在训练营中学习不少编程方面的知识，学着编写了不少Android方面的小程序，他踌躇满志一心想要报考&lt;em&gt;Android调查兵团&lt;/em&gt;。终于当投递了无数次申请了之后，调查兵团准许了小艾的申请，并给与了他一次面试的机会。&lt;/p&gt;
&lt;p&gt;到了要进行面试的日子，考官发放了一个题目，上面写道：“&lt;strong&gt;请编写一个如下图的自定义控件&lt;/strong&gt;”&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/X1ZyPpl.png&quot; alt=&quot;pic1&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="https://keep2iron.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>React-Native通信实现原理</title>
    <link href="https://keep2iron.github.io/2018/08/19/ReactNative%E9%80%9A%E4%BF%A1%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>https://keep2iron.github.io/2018/08/19/ReactNative通信实现原理/</id>
    <published>2018-08-19T07:46:34.000Z</published>
    <updated>2018-11-05T02:44:14.255Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="react native" scheme="https://keep2iron.github.io/tags/react-native/"/>
    
  </entry>
  
  <entry>
    <title>okhttp源码解析</title>
    <link href="https://keep2iron.github.io/2018/04/29/okhttp%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://keep2iron.github.io/2018/04/29/okhttp源码解析/</id>
    <published>2018-04-29T02:41:03.000Z</published>
    <updated>2018-08-19T08:02:48.941Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/pmIxXFe.png" alt></p><p>安卓开发领域上<a href="https://github.com/square/okhttp" target="_blank" rel="noopener">Okhttp</a>、<a href="https://github.com/square/retrofit" target="_blank" rel="noopener">Retrofit</a>、<a href="https://github.com/ReactiveX/RxJava" target="_blank" rel="noopener">RxJava</a>无疑已经成为了开发过程中的三板斧。在安卓6.0中谷歌删除了HttpClient的相关代码，并且在系统层面上使用了OkHttp，因此足以说明了这个框架的优秀。</p><p><a href="https://github.com/android-cn/android-open-project-analysis" target="_blank" rel="noopener">我们不重复造轮子不表示我们不需要知道轮子该怎么造及如何更好的造!</a> </p><a id="more"></a><p>用了OkHttp已经一年多之后，现在是时候来一探究竟了!!</p><h2 id="整体思路"><a href="#整体思路" class="headerlink" title="整体思路"></a>整体思路</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.imgur.com/pmIxXFe.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;安卓开发领域上&lt;a href=&quot;https://github.com/square/okhttp&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Okhttp&lt;/a&gt;、&lt;a href=&quot;https://github.com/square/retrofit&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Retrofit&lt;/a&gt;、&lt;a href=&quot;https://github.com/ReactiveX/RxJava&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;RxJava&lt;/a&gt;无疑已经成为了开发过程中的三板斧。在安卓6.0中谷歌删除了HttpClient的相关代码，并且在系统层面上使用了OkHttp，因此足以说明了这个框架的优秀。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/android-cn/android-open-project-analysis&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;我们不重复造轮子不表示我们不需要知道轮子该怎么造及如何更好的造!&lt;/a&gt; &lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>记录-DockerCE安装</title>
    <link href="https://keep2iron.github.io/2017/09/06/%E8%AE%B0%E5%BD%95-DockerCE%E5%AE%89%E8%A3%85/"/>
    <id>https://keep2iron.github.io/2017/09/06/记录-DockerCE安装/</id>
    <published>2017-09-06T01:52:58.000Z</published>
    <updated>2018-08-19T08:06:04.863Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/EN8O4bt.png" width="680"></p><p>配置如下:<br>Ubuntu 16.04LTS(64位版本)</p><p>本文的大部分步骤来自于docker的官方文档</p><blockquote><p><a href="https://docs.docker.com/engine/installation/linux/docker-ce/ubuntu/" target="_blank" rel="noopener">https://docs.docker.com/engine/installation/linux/docker-ce/ubuntu/</a></p></blockquote><a id="more"></a><p><strong>Docker是一种容器化的一种技术</strong></p><p>由于docker目前分为了两个版本一个是商业版，一个是社区版，因此这里我们选择的是社区版也就是CE版本。</p><h5 id="Docker是一种类似虚拟机的一种技术，但是比虚拟机要轻量的多。"><a href="#Docker是一种类似虚拟机的一种技术，但是比虚拟机要轻量的多。" class="headerlink" title="Docker是一种类似虚拟机的一种技术，但是比虚拟机要轻量的多。"></a>Docker是一种类似虚拟机的一种技术，但是比虚拟机要轻量的多。</h5><h4 id="1-docker-ce安装的运行环境"><a href="#1-docker-ce安装的运行环境" class="headerlink" title="1.docker ce安装的运行环境"></a>1.docker ce安装的运行环境</h4><p>DockerCE的安装版本的要求</p><ul><li>Zesty 17.04</li><li>Xenial 16.04 (LTS)</li><li>Trusty 14.04 (LTS)</li></ul><p>如果你的系统是14.04版本则需要安装linux-image-extra-*，因为docker需要这两个包。</p><pre><code>sudo apt-get updatesudo apt-get install \linux-image-extra-$(uname -r) \linux-image-extra-virtual</code></pre><h4 id="2-删除之前版本的docker"><a href="#2-删除之前版本的docker" class="headerlink" title="2.删除之前版本的docker"></a>2.删除之前版本的docker</h4><p>之前版本的docker叫做docker或者docker-engine，如果之前安装过，卸载它们</p><pre><code>sudo apt-get remove docker docker-engine docker.io</code></pre><p>现在我们安装的docker的包名叫做<strong>docker-ce</strong></p><h4 id="3-安装docker-ce"><a href="#3-安装docker-ce" class="headerlink" title="3.安装docker-ce"></a>3.安装docker-ce</h4><p>1.更新包的索引</p><pre><code>sudo apt-get update</code></pre><p>2.安装允许让apt允许的ssl仓库的包(ps:\代表这句脚本没有写完，进行换行)</p><pre><code>sudo apt-get install \apt-transport-https \ca-certificates \curl \software-properties-common</code></pre><p>3.添加Docker GPG Key</p><pre><code>curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</code></pre><p>4.设置仓库地址,这里设置的x86的仓库地址</p><pre><code>sudo add-apt-repository \   &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \   $(lsb_release -cs) \   stable&quot;</code></pre><p>5.安装<br>ubuntu14.04以上的版本都是自带docker安装包的,所以可以直接安装,但是这个一般不是最新版本,所以一般需要进行更新源</p><pre><code>sudo apt-get updatesudo apt-get install docker.io</code></pre><p>2.安装完成了之后可以通过以下命令进行查看安装版本<br>    docker -v</p><p>3.下载docker的镜像</p><pre><code>docker run ubuntu:15.10 /bin/echo &quot;Hello world&quot;</code></pre><h5 id="重点来了！！镜像地址默认是国外的dockerhub，国内速度较慢，因此需要一个国内镜像去加速，这里使用的是的DaoCloud"><a href="#重点来了！！镜像地址默认是国外的dockerhub，国内速度较慢，因此需要一个国内镜像去加速，这里使用的是的DaoCloud" class="headerlink" title="重点来了！！镜像地址默认是国外的dockerhub，国内速度较慢，因此需要一个国内镜像去加速，这里使用的是的DaoCloud"></a>重点来了！！镜像地址默认是国外的dockerhub，国内速度较慢，因此需要一个国内镜像去加速，这里使用的是的DaoCloud</h5><p>如果本地没有ubuntu 15.10的镜像，那么docker会去从仓库中下载，但是下载的速度很慢。因此这里使用了Docker镜像的加速器</p><p><a href="https://www.daocloud.io/mirror#accelerator-doc" target="_blank" rel="noopener">https://www.daocloud.io/mirror#accelerator-doc</a></p><p>通过下面的命令即可完成配置加速器。</p><pre><code>curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://d606b909.m.daocloud.io</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.imgur.com/EN8O4bt.png&quot; width=&quot;680&quot;&gt;&lt;/p&gt;
&lt;p&gt;配置如下:&lt;br&gt;Ubuntu 16.04LTS(64位版本)&lt;/p&gt;
&lt;p&gt;本文的大部分步骤来自于docker的官方文档&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.docker.com/engine/installation/linux/docker-ce/ubuntu/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://docs.docker.com/engine/installation/linux/docker-ce/ubuntu/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Docker" scheme="https://keep2iron.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>炫酷ViewPager指示器效果</title>
    <link href="https://keep2iron.github.io/2017/07/31/%E7%82%AB%E9%85%B7ViewPager%E6%8C%87%E7%A4%BA%E5%99%A8%E6%95%88%E6%9E%9C/"/>
    <id>https://keep2iron.github.io/2017/07/31/炫酷ViewPager指示器效果/</id>
    <published>2017-07-31T10:12:34.000Z</published>
    <updated>2018-08-21T16:44:07.219Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://i.imgur.com/FRwSDei.gif" alt></p><h1 id="写在前面的话"><a href="#写在前面的话" class="headerlink" title="写在前面的话"></a>写在前面的话</h1><p>本文的源起是在有一天在网上看到的一个挺不错的一个效果而产生的一个想法，正好因为这段时间公司闲了下来，因此想着练习一下中定义view。</p><a id="more"></a><h5 id="本文以尽可能通俗的语言，让大家理解整个的绘制过程，尽量不粘贴代码-因为我认为思路往往比代码更重要-。还有就是可能对数学无感的人和不太友好。"><a href="#本文以尽可能通俗的语言，让大家理解整个的绘制过程，尽量不粘贴代码-因为我认为思路往往比代码更重要-。还有就是可能对数学无感的人和不太友好。" class="headerlink" title="本文以尽可能通俗的语言，让大家理解整个的绘制过程，尽量不粘贴代码(因为我认为思路往往比代码更重要)。还有就是可能对数学无感的人和不太友好。"></a>本文以尽可能通俗的语言，让大家理解整个的绘制过程，尽量不粘贴代码(因为我认为思路往往比代码更重要)。还有就是可能对数学无感的人和不太友好。</h5><h2 id="一、这篇文章你将会学到什么"><a href="#一、这篇文章你将会学到什么" class="headerlink" title="一、这篇文章你将会学到什么?"></a>一、这篇文章你将会学到什么?</h2><blockquote><p>1.学到一些自定义绘制中的一些技巧。</p><p>2.学习Bezier的一些相关知识。</p><p>3.利用面向对象更好的去解决一些复杂的问题。</p></blockquote><h2 id="二、准备"><a href="#二、准备" class="headerlink" title="二、准备"></a>二、准备</h2><h3 id="2-1-UI效果展示"><a href="#2-1-UI效果展示" class="headerlink" title="2.1 UI效果展示"></a>2.1 UI效果展示</h3><h3 id="原始效果图"><a href="#原始效果图" class="headerlink" title="原始效果图:"></a>原始效果图:</h3><p><img src="http://i.imgur.com/ybV4NBB.gif" alt></p><h3 id="实际运行图"><a href="#实际运行图" class="headerlink" title="实际运行图:"></a>实际运行图:</h3><p><img src="http://i.imgur.com/FRwSDei.gif" alt></p><h3 id="2-2-思考"><a href="#2-2-思考" class="headerlink" title="2.2 思考"></a>2.2 思考</h3><blockquote><p>1.界面由 ViewPager + 自定义指示器</p><p>2.ViewPager的间隔效果.</p><p>3.小球能够和ViewPager联动不断变化</p></blockquote><h3 id="2-3-ViewPager效果实现"><a href="#2-3-ViewPager效果实现" class="headerlink" title="2.3 ViewPager效果实现"></a>2.3 ViewPager效果实现</h3><p>我们看到上面的是一个可以滑动的ViewPager，但是默认的ViewPager是一页只能显示一个Item的，因此经过多方查找，我找到了如下方法可以实现这个效果:</p><h5 id="2-3-1-ViewPager的布局"><a href="#2-3-1-ViewPager的布局" class="headerlink" title="2.3.1 ViewPager的布局"></a>2.3.1 ViewPager的布局</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">android.support.v4.view.ViewPager</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:layout_above</span>=<span class="string">"@+id/bezierIndicator"</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:id</span>=<span class="string">"@+id/viewPager"</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:layout_centerVertical</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:layout_gravity</span>=<span class="string">"bottom"</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:clipToPadding</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:overScrollMode</span>=<span class="string">"never"</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:paddingBottom</span>=<span class="string">"10dp"</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:paddingEnd</span>=<span class="string">"@dimen/card_padding"</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:paddingLeft</span>=<span class="string">"@dimen/card_padding"</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:paddingRight</span>=<span class="string">"@dimen/card_padding"</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:paddingStart</span>=<span class="string">"@dimen/card_padding"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h5 id="android-clipToPadding-”false”"><a href="#android-clipToPadding-”false”" class="headerlink" title="android:clipToPadding=”false”"></a>android:clipToPadding=”false”</h5><p>就是说控件的绘制区域是否在padding里面的，true的情况下绘制的区域不包括了Padding占据的那部分<br><img src="http://i.imgur.com/uxdywV1.png" alt><br>蓝线的部分即为我们绘制的区域，因为设置了true，而且默认是true，而我们想要把绘制区域在padding中那么就要将这个属性设置为false了。</p><h5 id="android-overScrollMode-”never”"><a href="#android-overScrollMode-”never”" class="headerlink" title="android:overScrollMode=”never”"></a>android:overScrollMode=”never”</h5><p>我们滑动的时候经常可以看到谷歌很多滑动的原生控件上都具有一个明显的特征(5.0以上)<br><img src="http://i.imgur.com/DewB1bC.png" alt></p><p>有一个阴影对吧，这个效果默认是有的，这个效果的含义就是滑动的时候可以滑出区域外，有一个简单的回弹效果，如果不想要这个阴影，也就是这个回弹，那么可以将这个属性设置成never即可。</p><p>再来就是设置padding值。但是还有没结束。</p><h5 id="2-3-2-ViewPager的代码设置"><a href="#2-3-2-ViewPager的代码设置" class="headerlink" title="2.3.2 ViewPager的代码设置"></a>2.3.2 ViewPager的代码设置</h5><pre><code>mViewPager = (ViewPager) findViewById(R.id.viewPager);mViewPager.setOffscreenPageLimit(3);mViewPager.setPageMargin(60);</code></pre><p>1.设置viewpager缓存页数，因为默认ViewPager只加载一页，因此这里设置成三个，让其全部加载。<br>2.设置setPageMargin是为了控制每一页Page之间的大小。产生一个间隔的效果。这里和padding的不同在于Padding是设置了边界，也就是第一页左边的那个大小，因此这里是设置每一页之间的大小的。</p><p>经过了上面的配置，我们的ViewPager就可以完成了下面所示的效果<br><img src="http://i.imgur.com/TDZ8ZEf.png" alt></p><h3 id="2-4-BezierIndicator"><a href="#2-4-BezierIndicator" class="headerlink" title="2.4 BezierIndicator"></a>2.4 BezierIndicator</h3><p>上面我们一步一步实现了ViewPager的效果，接下来的重头戏就是如何去实现小球？</p><p>细心的我们可以发现这个球一共经历了5个状态，并且动画是<em>通过形状的变化加上画布的位移而产生</em>的<br><img src="http://i.imgur.com/rHwii48.png" alt><br><img src="http://i.imgur.com/987EBUH.gif" alt></p><p>下面我们来一步一步来进行Beizer的绘制工作</p><h4 id="2-4-1-预热一下"><a href="#2-4-1-预热一下" class="headerlink" title="2.4.1 预热一下"></a>2.4.1 预热一下</h4><p>在开始画之前我们先来看一下这个Beizer的相关api，关于Bezier的数学原理在这里不会详细阐述(网络上有大量的说明，如果有兴趣可以自行查阅)。</p><p>在具体的讲解之前，我们来看看如果利用Bezier画圆。</p><p>下面这个图利用了PS中的钢笔工具进行了绘制，也就是说这个圆是由4条Bezier曲线组成的。<br><img src="http://i.imgur.com/dMXbG4Q.png" alt></p><p>利用如下代码即可完成绘制<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mPath.cubicTo(x1,y1,x2,y2,x3,y3);//x1,x2都是控制点,x3是终点</span><br></pre></td></tr></table></figure></p><p><img src="http://i.imgur.com/i4jslVi.png" alt></p><p>P1 P2 P3 P4分别是圆上的4个端点,它们连线的圆点即为该点的控制点。M为控制点到圆点的距离,那么M值的大小直接影响了曲线变化！</p><p>代码如下:</p><pre><code>mPath.reset();mPath.reset();mPath.moveTo(p1.x, p1.y);mPath.cubicTo(p1.rightX, p1.rightY, p2.bottomX, p2.bottomY, p2.x, p2.y);mPath.cubicTo(p2.topX, p2.topY, p3.rightX, p3.rightY, p3.x, p3.y);mPath.cubicTo(p3.leftX, p3.leftY, p4.topX, p4.topY, p4.x, p4.y);mPath.cubicTo(p4.bottomX, p4.bottomY, p1.leftX, p1.leftY, p1.x, p1.y);</code></pre><p>代码中，先将Path移动到p1点</p><pre><code>mPath.moveTo(p1.x, p1.y)</code></pre><p>然后利用p1右边的控制点,p2下方的控制点，以及p2点的坐标即可画出p1到p2的曲线</p><pre><code>mPath.cubicTo(p1.rightX, p1.rightY, p2.bottomX, p2.bottomY, p2.x, p2.y);</code></pre><p>其他的跟上面的写法是一样的，就不再赘述。</p><p>p1,p3的控制点由于是在水平方向上的，于是控制点的计算使用了如下的代码:</p><pre><code>this.x = x;this.y = y;this.m = m;leftX = x - m;rightX = x + m;leftY = y;rightY = y;</code></pre><p>根据资料查询的结果: M =  <em>0.5522847498</em>时，曲线的绘制就是一个圆弧。</p><blockquote><p><a href="http://spencermortensen.com/articles/bezier-circle/" target="_blank" rel="noopener">http://spencermortensen.com/articles/bezier-circle/</a>有一篇文章专门讲解了M点计算的原理。</p></blockquote><h2 id="三、开始"><a href="#三、开始" class="headerlink" title="三、开始"></a>三、开始</h2><h4 id="3-1来面向对象一下"><a href="#3-1来面向对象一下" class="headerlink" title="3.1来面向对象一下"></a>3.1来面向对象一下</h4><p><img src="http://i.imgur.com/JpN6uGa.png" alt></p><p>首先将小球进行了抽象，抽取成一个单独的类<em>BerizerCircle</em>，然后画出小球的时候需要一些控制点的坐标。在这里我们分为了水平端点(<em>HorizontalPoint</em>)和垂直端点坐标(<em>VerticalPoint</em>)。</p><p>那么问题来了什么是水平端点和垂直端点呢？哈哈哈，其实这里我只是自己这么称呼的而已，不要介意。</p><p>水平端点即为在水平方向上具有控制点的点，对应了我们刚才图上所示的P1,P3的两个端点，那么垂直端点也就是P2、P4了</p><p>下面来看一下其中的<strong>HorizontalPoint.java</strong>的构造函数</p><pre><code>public HorizontalPoint(float x, float y, float m) {    this.x = x;    this.y = y;    this.m = m;    leftX = x - m;    rightX = x + m;    leftY = y;    rightY = y;}</code></pre><p>这个构造函数的意思就是，通过设置端点的坐标(x,y)，以及端点到控制点的距离(M)，即可得到端点坐标和两个控制点的坐标。那么VerticalPoint类的构造函数的思路也就不用多说了。</p><p>那么构造端点方法可以通过如下的方式进行了</p><pre><code>p1 = new HorizontalPoint(0, R, M);p2 = new VerticalPoint(R, 0, M);p3 = new HorizontalPoint(0, -R, M);p4 = new VerticalPoint(-R, 0, M);</code></pre><p>如果上述不是看的很懂那么再一个图来理解一下<br><img src="http://i.imgur.com/XgOAb5N.png" alt></p><p>那么利用R,M我们可以把图中所有的端点和控制点进行了计算。</p><h4 id="3-2绘制流程"><a href="#3-2绘制流程" class="headerlink" title="3.2绘制流程"></a>3.2绘制流程</h4><p>下面我们来看一下<em>BezierCircle</em>下面这个核心的函数，思路就是通过滑动的百分比，来控制图形的形态。</p><pre><code>/** * 通过ViewPager的百分比进行控制显示的状态 * * @param fromPos * @param toPos * @param positionOffset Value from [0, 1) indicating the offset from the page at position. * @see android.support.v4.view.ViewPager.OnPageChangeListener */public void drawByPositionOffset(int fromPos, int toPos, float positionOffset) {    boolean isTurnRight = toPos - fromPos &gt; 0;    if (positionOffset &gt;= 0 &amp;&amp; positionOffset &lt;= 0.2f) {        buildCircle1(positionOffset, isTurnRight);    } else if (positionOffset &lt;= 0.5f) {        buildCircle2(positionOffset, isTurnRight);    } else if (positionOffset &lt;= 0.8f) {        buildCircle3(positionOffset, isTurnRight);    } else if (positionOffset &lt;= 0.9f) {        buildCircle4(positionOffset, isTurnRight);    } else if (positionOffset &lt;= 1.0f) {        buildCircle5(positionOffset, isTurnRight);    }}</code></pre><p><img src="http://i.imgur.com/Q0YEXmf.png" alt></p><p>上图就是一个小球变化的一个趋势图，整体的一个绘制思路和流程在上图可以进行了完整的体现。</p><p>那么下面我们来具体分析一下，小球在各个滑动区间中具体是如何变化的吧！</p><p><strong>3.2.1平移距离在(0,0.2]的范围内时</strong></p><p><img src="http://i.imgur.com/ohP8VAU.gif" alt></p><p>p2点在这个状态的中从(R,0)变成了(9/5 *R,0),<strong>positionOffset / 0.2f为这个区间(0,0.2]的变化率</strong>。</p><blockquote><p>x = R + 4 / 5.0f <em> R </em> P,P是变化率也就是positionOffset / 0.2f</p></blockquote><p>下面是代码：</p><pre><code>/** * 因为变化率是0 - 0.2f区间进行变化, 而p2点的x坐标则是从R - 4/5R之间进行变化, * 因此x = R + (4/5R * (变化率的百分比)) * 变化率的百分比为 pos / 0.2f   0.2为区间值,pos在0 - 0.2f之间变化 * * @param positionOffset */private void buildCircle1(float positionOffset) {   //0 &lt; pos &lt;=0.2f    p1.setX(0);    p3.setX(0);    p4.setX(-R);    p2.setX(R + 4 / 5.0f * R * positionOffset / 0.2f);}</code></pre><p>如果对上面的公式或者注释你还是无法有一个直观的理解，可以结合下面的图来进行进一步的加深<br><img src="http://i.imgur.com/GdUdPvK.png" alt></p><p>在buildCircle1中我们做的就是将P2点的坐标不断进行水平移动，从而让小球从状态1变化到了状态2了。</p><p><strong>3.2.2平移距离在(0.2,0.5]的范围内时</strong></p><p><img src="http://i.imgur.com/mqA6dSV.gif" alt></p><p>在这个过程中我们需要将小球进行变化成一个椭圆<br>通过下图我们可以看到如果单纯将P2点垂直方向上的控制点的距离进行增大，图形的右边就更加的椭圆了，因为要对称，所以同时改变P2点和p4的垂直方向上M的距离，就可以让这两边的曲线更加接近椭圆。<br><img src="http://i.imgur.com/REGqLHG.png" alt></p><p>但是还有一个问题，图形目前是不对称的，在上一个状态中我们移动了p2点的坐标R-&gt;9/5R，因此要让P2和p4对称，因此p1和p3也要同时进行移动，让其两点的x轴的坐标移动到新的中心点坐标。</p><p><strong>新的中心点在哪里？</strong></p><p>我们重新来看下坐标<br>P1(0,R)，P2(5/9R,0),P3(0，-R),P4（-R,0）<br>新的中心点的x轴的坐标为</p><blockquote><p>x = (p4.x + (p2.x - p4.x) / 2) * P</p></blockquote><p>我们可以看到公式中有一个除2的操作，为什么要除2呢?<br><img src="http://i.imgur.com/Q6tTjLZ.png" alt></p><p><strong>可以看到正方形，通过将右边的左边的点进行平移1个单位后</strong>,中心点从(0,0)变化至(0.5,0)。通过这个公式p4.x + (p2.x - p4.x) / 2,这里我们将p2.x = 2，p4.x = -1，通过计算得出了0.5，因此这就是为什么要这么写的原因了。</p><p>下面是代码：</p><pre><code>/** * 在这个过程中需要将Circle变成一个椭圆 * 这个里p2点的x是R + 4 / 5R,因此椭圆的长轴的距离为 R+ R + 4 / 5R = 14 / 5R * &lt;p&gt; * 然后 14 / 5R /2 为长轴一半 - R即为椭圆中心点的坐标 * * @param positionOffset */private void buildCircle2(float positionOffset) {   //0.2 &lt; pos &lt;= 0.5f    p2.setX(R + 4 / 5.f * R);    float x = ((R + R + 4 / 5.f * R) / 2.f - R) * (positionOffset - 0.2f) / 0.3f;    p1.setX(x);    p3.setX(x);    float m = M + M * 2 / 3.f * (positionOffset - 0.2f) / 0.3f;    p4.setM(m);    p2.setM(m);}</code></pre><p><strong>3.2.3平移距离在(0.5,0.8]的范围内时</strong></p><p><img src="http://i.imgur.com/3GKt8Rv.gif" alt></p><p>在这个过程中我们需要将椭圆变成如我们状态2那样子的有一头比较尖的圆形。</p><p>p2.x从9/5R 变化至 R</p><p>p4.x从-R 变化至 -9/5R</p><p>p1.x从((R +  9/5R) / 2.f - R)/2 变化至 0</p><p>p3.x从((R +  9/5R) / 2.f - R)/2 变化至 0</p><pre><code>/** * 在这个过程中需要将circle从一个椭圆变成左边较尖锐的椭圆 * * @param positionOffset */private void buildCircle3(float positionOffset) {       //0.5 - 0.8f    float x = ((R + R + 4 / 5.f * R) / 2.f - R) - ((R + R + 4 / 5.f * R) / 2.f - R) * (positionOffset - 0.5f) / 0.3f;    p1.setX(x);    p3.setX(x);    float m = 5.f * M / 3 - 2.f * M / 3 * (positionOffset - 0.5f) / 0.3f;    p2.setM(m);    p4.setM(m);    float p4X = -R - 4 / 5.f * R * (positionOffset - 0.5f) / 0.3f;    p4.setX(p4X);    float p2X = 9 / 5.f * R - 4 / 5.f * R * (positionOffset - 0.5f) / 0.3f;    p2.setX(p2X);}</code></pre><p><strong>3.2.4恢复成圆形(0.8,0.9]</strong></p><p><img src="http://i.imgur.com/AZFm3Sd.gif" alt></p><p>p4.x 从-9/5R 变化至 -R。并且重置一下p1、p2、p3的坐标</p><pre><code>private void buildCircle4(float positionOffset) {       //0.8 - 1.0    float p4X = -9 / 5.f * R + 4 / 5.f * R * (positionOffset - 0.8f) / 0.2f;    p4.setX(p4X);    p1.setX(0);    p3.setX(0);    p2.setX(R);}</code></pre><p><strong>3.2.5让小球进行回弹起来吧[0.9,1.0]</strong></p><p><img src="http://i.imgur.com/kwXQmEN.gif" alt></p><pre><code>double value = Math.sin(Math.toRadians((positionOffset - 0.9f) / 0.1f * 180));p4.setX((float) (-R +  R / 2.0f * value));</code></pre><p>为社么这里使用了sin函数呢?<br><img src="http://i.imgur.com/L0qETmy.jpg" alt></p><p><strong>在sin函数中x在[0，π/2]y轴的变化过程是[0,1]，x在[π/2，π]之间y轴的变化过程是[1,0]，这个y轴的变化过程正好满足我们这里回弹过程的变化率！！！因此使用sin作为这里控制回弹效果的产生是再合适不过的了。</strong></p><p><strong>3.2.6让小球进行平移</strong></p><p>前面我们都是通过改变p1,p2,p3,p4的坐标来改变小球的形状，然而还要进行添加位移，这样才能形成一个完整的动画，我在这里有两个思路</p><p>1.通过drawPath方法，不断地改变小球的x,y的位置来进行，然而这个的代价就是所有的坐标点都需要进行变化加上平移距离，得出最后的点的坐标</p><p>2.通过Canvas的translate方法，移动画布来达到我们这里平移动画的产生效果，显然，这一种方法我们不需要进行坐标转变即可完成动画效果，因为本控件也是采用了这一种方案。</p><p><img src="http://i.imgur.com/cOCWL6Q.png" alt></p><pre><code>canvas.save();canvas.translate(mStartPoint.x        + translateMoveSize * mPercent        + (span + 2 * R) * mViewPagerPosition, mStartPoint.y);Path path = mBezierCircle.buildPath();mPaint.setColor(color);canvas.drawPath(path, mPaint);canvas.restore();</code></pre><p>mStartPoint.x是计算的小球的起始位置。</p><pre><code>mStartPoint = new Point(span + R, h / 2);</code></pre><p>translateMoveSize是小球移动的一个单位的距离，mPercent是移动的百分比，mViewPagerPosition当前Page的位置。mStartPoint.x 先让小球平移到初始位置,然后加上 (span + 2 <em> R) </em> mViewPagerPosition当前页滑动页的距离，然后加上滑动的百分比在滑动距离上的比值，计算出最后的平移距离。</p><p>span的计算是通过下面的公式进行等分的计算出来的距离。</p><pre><code>span = (getWidth() - (count * R * 2)) / (count + 1);</code></pre><p><strong>3.2.7绑定ViewPager进行联动</strong></p><p>监听ViewPager的滑动事件自然是通过addOnPageChanageListener进行滑动的监听。在这里我们使用了如下的方法：</p><pre><code>@Overridepublic void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) {    if (!isInitialise) return;    if (!isMoveByTouch) {        boolean right = position + positionOffset - mViewPagerPosition &gt; 0;        if (positionOffset != 0.0f) {            //位移未完成            startColor = roundColors[mViewPagerPosition];            endColor = roundColors[(mViewPagerPosition + (right ? 1 : -1)) % roundColors.length];            color = mBezierCircle.getCurrentColor(right ? positionOffset : 1 - positionOffset, startColor, endColor);        }        moveBezierCirclePercent(position, positionOffset);    }}</code></pre><p>在这里我们先来看一下ViewPager数值的变化规律:<br>这是从左向右滑动的时候,从第0页向第一页滑动position从0变化到1，positionOffset:0.0到0.999最后在完成翻页了之后变成了0.0.</p><p><img src="http://i.imgur.com/h5iaGTj.png" alt></p><p>这是从右向左滑动的时候</p><p><img src="http://i.imgur.com/p32wjpw.png" alt></p><pre><code>boolean right = position + positionOffset - mCurrentPosition &gt; 0;if (positionOffset != 0.0f) {    //位移未完成    startColor = roundColors[mCurrentPosition];    endColor = roundColors[mCurrentPosition + (right ? 1 : -1)];    color = mBezierCircle.getCurrentColor(right ? positionOffset : 1 - positionOffset, startColor, endColor);}moveBezierCirclePercent(position, positionOffset);</code></pre><p>这里是颜色的相关计算,mCurrentPosition是当前页的位置。</p><p>0到1页时,颜色值从a-b进行变化,变化率从0.0到0.9</p><p>1到0页时,颜色值从b-a进行变化,变化率从0.9到0.0,因此需要进行1 - positionOffset让其从0.0到0.9进行变化，才满足我们变化的颜色公式。</p><p>下面是颜色变化的计算函数</p><pre><code>public int getCurrentColor(float percent, int startColor, int endColor) {    f[0][0] = (startColor &amp; 0xff0000) &gt;&gt; 16;    f[0][1] = (startColor &amp; 0x00ff00) &gt;&gt; 8;    f[0][2] = (startColor &amp; 0x0000ff);    f[1][0] = (endColor &amp; 0xff0000) &gt;&gt; 16;    f[1][1] = (endColor &amp; 0x00ff00) &gt;&gt; 8;    f[1][2] = (endColor &amp; 0x0000ff);    for (int i = 0; i &lt; 3; i++) {        result[i] = (int) (f[0][i] + (f[1][i] - f[0][i]) * percent);    }    return Color.rgb(result[0], result[1], result[2]);}</code></pre><h4 id="3-3-点击产生的涟漪效果"><a href="#3-3-点击产生的涟漪效果" class="headerlink" title="3.3 点击产生的涟漪效果"></a>3.3 点击产生的涟漪效果</h4><p>实际的原理是通过属性动画进行改变画笔画圆的半径，然后通过设置画笔的粗细程度来完成这一效果的实现。</p><p>在onDraw方法画出点击的产生的圆</p><pre><code>private void drawTouchWave(Canvas canvas) {    if (mTouchPoint.isShow()) {        canvas.drawCircle(mTouchPoint.getCenterX(), mTouchPoint.getCenterY(), mTouchPoint.R, mTouchPoint.mPaint);    }}</code></pre><p>在onTouchEvent进行点击效果的触发</p><pre><code>private int getDistance(float x1, float y1, float x2, float y2) {    return (int) Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));}@Overridepublic boolean onTouchEvent(MotionEvent event) {    super.onTouchEvent(event);    switch (event.getActionMasked()) {        case MotionEvent.ACTION_DOWN:            for (int i = 0; i &lt; mBitmapRects.length; i++) {                int distance = getDistance(mBitmapRects[i].centerX(), mBitmapRects[i].centerY(), event.getX(), event.getY());                if (distance &lt;= R) {                    mTouchPoint.setCenterX((int) mBitmapRects[i].centerX());                    mTouchPoint.setCenterY((int) mBitmapRects[i].centerY());                    mTouchPoint.setShow(true);                    startWave();                    startMoveBezierCircleByTouch(mCurrentPosition, i);                    break;                }            }            break;    }    return true;}</code></pre><p>通过两点之间的距离公式，判断是否在点击的区域范围内，然后通过startWave()方法进行显示点击的涟漪效果，通过startMoveBezierCircleByTouch方法进行从当前位置，跳转的指定的位置的平移变换。</p><pre><code>/** * 开启点击的水波纹 */private void startWave() {    ValueAnimator valueAnimator = ValueAnimator.ofFloat(R, 4.0f / 3 * R);    valueAnimator.setDuration(400);    valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {        @Override        public void onAnimationUpdate(ValueAnimator animation) {            float value = (float) animation.getAnimatedValue();            float percent = (value - R) / (1.f / 3 * R);            mTouchPoint.setStrokeWidth(TouchPoint.STROKE_WIDTH * (1 - percent));            mTouchPoint.R = value;            invalidate();        }    });    valueAnimator.addListener(new AnimatorListenerAdapter() {        @Override        public void onAnimationEnd(Animator animation) {            mTouchPoint.setShow(false);            invalidate();        }    });    valueAnimator.start();}</code></pre><p>通过改变R的半径以及画笔的粗细程度，即可完成了这一效果的绘制过程</p><p><img src="http://i.imgur.com/nBVpmbw.gif" alt></p><h3 id="3-4-点击产生的位移"><a href="#3-4-点击产生的位移" class="headerlink" title="3.4 点击产生的位移"></a>3.4 点击产生的位移</h3><p>上面我们看到点击后通过属性动画完成涟漪效果的显示，<strong>同样我们可以利用属性动画，让其模拟viewPager的参数的变化过程，这样之前的ViewPager函数就可以进行调用就行了</strong>。</p><pre><code>private void startMoveBezierCircleByTouch(final int formPos, final int toPos) {    if (formPos == toPos) return;    final boolean isTurnRight = toPos - formPos &gt; 0;    translateMoveSize = Math.abs(toPos - formPos) * (span + 2 * R);    setDurationScroller();    //位移未完成    startColor = roundColors[formPos];    endColor = roundColors[toPos];    mViewPager.setCurrentItem(toPos);    ValueAnimator valueAnimator = ValueAnimator.ofInt(0, Math.abs(translateMoveSize));    valueAnimator.setDuration(600);    valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {        @Override        public void onAnimationUpdate(ValueAnimator animation) {            isMoveByTouch = true;            int value = (int) animation.getAnimatedValue();            float percent = Math.abs(value * 1.0f) / Math.abs((toPos - formPos) * (span + 2 * R));            color = mBezierCircle.getCurrentColor(percent, startColor, endColor);            if (percent &gt;= 1.0f) {                isMoveByTouch = false;                translateMoveSize = span + 2 * R;                mViewPagerPosition = toPos;                setOriginScroller();                moveBezierCirclePercent(toPos, 0.0f);            } else {                moveBezierCirclePercent(isTurnRight ? formPos : toPos, isTurnRight ? percent : 1 - percent);            }        }    });    valueAnimator.start();}</code></pre><p>因为ViewPager在0页到1页的过程中position是0，positionOffset是0-0.9直到当滑动完成后变成了0，1页到0页的过程中positionOffset是从0.9 - 0，position是0，因此这里就是模拟这样子的参数而编写代码。</p><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>现在看一下之前的问题，看看心里有没有数</p><pre><code>do{    1.ViewPager一页显示多个item？    2.如何进行绘制一个不断变化的小球？    3.如何让小球进行和ViewPager的进行绑定？    4.如何让小球不断的进行变化？    5.如何生成点击后的涟漪效果？}while(不懂);</code></pre><p><img src="http://i.imgur.com/dhsnvVB.png" alt></p><p>最后非常感谢<strong><em>陈宇明</em></strong>大佬的细心指导,文章的结构顺序、还有内容都一一进行指正和阅读，很多地方都是根据其建议进行修改的。</p><p>本篇的分析就到此为止了，后面我会抽时间不断的完善这个demo，如果你有好的建议，请加Bravh交流群和我一起交流/学习，我在等你哟~！</p><h3 id="本项目地址"><a href="#本项目地址" class="headerlink" title="本项目地址"></a>本项目地址</h3><blockquote><p><a href="https://github.com/keep2iron/BezierIndicator" target="_blank" rel="noopener">https://github.com/keep2iron/BezierIndicator</a></p></blockquote><h5 id="在编写代码的过程中也并不是一帆风顺的，再次感谢广大的博主和开源作者，Android社区的繁荣离不开你们辛勤的劳动。下面是参考的博客地址和项目地址"><a href="#在编写代码的过程中也并不是一帆风顺的，再次感谢广大的博主和开源作者，Android社区的繁荣离不开你们辛勤的劳动。下面是参考的博客地址和项目地址" class="headerlink" title="在编写代码的过程中也并不是一帆风顺的，再次感谢广大的博主和开源作者，Android社区的繁荣离不开你们辛勤的劳动。下面是参考的博客地址和项目地址"></a>在编写代码的过程中也并不是一帆风顺的，再次感谢广大的博主和开源作者，Android社区的繁荣离不开你们辛勤的劳动。下面是参考的博客地址和项目地址</h5><blockquote><p><a href="http://blog.csdn.net/zanelove/article/details/50337623" target="_blank" rel="noopener">http://blog.csdn.net/zanelove/article/details/50337623</a></p><p><a href="http://www.jianshu.com/p/791d3a791ec2" target="_blank" rel="noopener">http://www.jianshu.com/p/791d3a791ec2</a></p><p><a href="https://github.com/Ulez/DropIndicator" target="_blank" rel="noopener">https://github.com/Ulez/DropIndicator</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://i.imgur.com/FRwSDei.gif&quot; alt&gt;&lt;/p&gt;
&lt;h1 id=&quot;写在前面的话&quot;&gt;&lt;a href=&quot;#写在前面的话&quot; class=&quot;headerlink&quot; title=&quot;写在前面的话&quot;&gt;&lt;/a&gt;写在前面的话&lt;/h1&gt;&lt;p&gt;本文的源起是在有一天在网上看到的一个挺不错的一个效果而产生的一个想法，正好因为这段时间公司闲了下来，因此想着练习一下中定义view。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Simple Record" scheme="https://keep2iron.github.io/tags/Simple-Record/"/>
    
  </entry>
  
  <entry>
    <title>编写一个编译时注入框架</title>
    <link href="https://keep2iron.github.io/2017/05/28/%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E7%BC%96%E8%AF%91%E6%97%B6%E6%B3%A8%E5%85%A5%E6%A1%86%E6%9E%B6/"/>
    <id>https://keep2iron.github.io/2017/05/28/编写一个编译时注入框架/</id>
    <published>2017-05-28T09:40:00.000Z</published>
    <updated>2017-05-28T15:02:44.663Z</updated>
    
    <content type="html"><![CDATA[<p>最近在折腾AnnotationProcessor，想着通过学习黄油刀来编写一个自己android编译时注入框架。<br>这个项目的地址是我的自己编写的一个AnnotationProcessor库</p><blockquote><p><strong><a href="https://github.com/keep2iron/Fast4Android-InjectView" target="_blank" rel="noopener">https://github.com/keep2iron/Fast4Android-InjectView</a></strong><br>如果觉得这篇文章有点用，请记得给个star哟</p></blockquote><p>学习的过程中发现了一些需要知道的api，在了解了这些api的情况下，那么我相信你可以对这个东西的掌握会更加的熟练和精通。</p><p>下面是我用到相关api，<strong>请在了解这些api的基础上阅读代码，这样可以事半功倍哟。</strong><br><strong>javax.annotation.processing</strong><br>这个包用来声明注释处理器并允许注释处理器与注释处理工具环境通信的工具。 <table><tr><th style="text-algin:center;">类名</th><th style="text-algin:center;">说明</th></tr><tr><td>interface ExecutableElement</td><td>表示某个类或接口的方法、构造方法或初始化程序（静态或实例）,包括注释类型元素.</td></tr><tr><td>interface PackageElement</td><td>表示一个包程序元素.</td></tr><tr><td>interface TypeElement </td><td>表示一个类或接口程序元素.</td></tr><tr><td>interface TypeParameterElement </td><td>表示一般类、接口、方法或构造方法元素的形式类型参数.</td></tr><tr><td>interface     VariableElement </td><td>表示一个字段、enum 常量、方法或构造方法参数、局部变量或异常参数.</td></tr></table></p><blockquote><p>其中还运用到了<a href="https://github.com/square/javapoet" target="_blank" rel="noopener">javapoet</a>的相关api，利用这个库的api进行生成java代码。</p></blockquote><blockquote><p>使用了@AutoService这个是google的一个类库<a href="https://github.com/google/auto" target="_blank" rel="noopener">Auto</a>用来进行生成META-INF信息,这样可以不用我们自己手动去配置了</p></blockquote><p><strong>编译时顺序图</strong>点击下图选中的gradle脚本即可生成文件</p><p><img src="http://i.imgur.com/QZyE8lR.png" alt></p><p><strong>在代码中调用bind方法的顺序图</strong></p><p><img src="http://i.imgur.com/6ELqej3.png" alt></p><p><strong>生成文件执行的顺序图</strong><br><img src="http://i.imgur.com/mZoLFXQ.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在折腾AnnotationProcessor，想着通过学习黄油刀来编写一个自己android编译时注入框架。&lt;br&gt;这个项目的地址是我的自己编写的一个AnnotationProcessor库&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;ht
      
    
    </summary>
    
    
      <category term="Android" scheme="https://keep2iron.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>记录AndroidProcess调试</title>
    <link href="https://keep2iron.github.io/2017/05/26/%E8%AE%B0%E5%BD%95AndroidProcess%E8%B0%83%E8%AF%95/"/>
    <id>https://keep2iron.github.io/2017/05/26/记录AndroidProcess调试/</id>
    <published>2017-05-26T07:48:42.000Z</published>
    <updated>2018-08-19T05:55:54.307Z</updated>
    
    <content type="html"><![CDATA[<p>记录AndroidProcess调试步骤</p><p><strong>第一步</strong>在AnnoProcessor中设置断点</p><p><img src="http://i.imgur.com/gWBxFFT.png" alt></p><a id="more"></a><blockquote><p>记录AndroidProcess调试步骤</p><p><strong>第一步</strong>在AnnoProcessor中设置断点</p><p><img src="http://i.imgur.com/gWBxFFT.png" alt></p><p><strong>第二步</strong>修改</p><p>gradle.properties</p><p><strong>第三步</strong>添加如下代码</p><p>第一行的作用是允许gradle开启守护进程</p><p>第二行代码是设置gradle连接的端口号.这里原先是设置为5005，但是由于报错，说端口号被占用，因此改为5010</p><p><code>org.gradle.daemon=true</code></p><p><code>org.gradle.jvmargs=-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5010</code></p><p><strong>第四步</strong>在上一步的基础上在as控制台运行如下命令：</p><p><code>gradle --daemon</code></p><p>你可能会有如下的报错：</p><p><img src="http://i.imgur.com/gMRzcuZ.png" alt></p><p><strong>少年莫慌，这是因为gradle没有在你的电脑中配置的缘故，因此可以将gradle改成gradlew！！！！！</strong></p><p>gradlew相当于是gradle的一个包装，相当于接口，因此实现类是由，.gradle文件夹中的gradle-wrapper.properties中的distributionUrl后面指定的gradle版本决定的<strong>（PS:在这里可以看到面向接口的好处了吧）</strong></p><p>运行完成之后，gradle就已经开启了守护进程，他会监听在我们刚刚配置的指定的端口号上</p><p><strong>第五步</strong>配置AndroidStudio</p><p><img src="http://i.imgur.com/lmCs3Wd.png" alt></p><p><img src="http://i.imgur.com/B1tGwYV.png" alt></p><p><img src="http://i.imgur.com/y0vgumU.png" alt></p><p><strong>然后点击ok就可以了</strong>然后界面上就有这个配置项了，下面开始运行它，点击那个小虫子的图标，debug模式运行</p><p><img src="http://i.imgur.com/RQNGkba.png" alt></p><p><img src="http://i.imgur.com/hmokmXh.png" alt></p><p><strong>第五步</strong>最后一步啦，在命令行执行如下命令，让其进行编译，因此我们</p><p><code>gradle clean assembleDebug</code></p><p>在运行的过程中</p><p><img src="http://i.imgur.com/jivxUeh.png" alt></p><p>这里可以看到我们的断点执行啦！！ok到此AnnotationProcessor的调试就到此结束了~！</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录AndroidProcess调试步骤&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一步&lt;/strong&gt;在AnnoProcessor中设置断点&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/gWBxFFT.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="https://keep2iron.github.io/tags/Android/"/>
    
  </entry>
  
</feed>
