<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-08-18T17:08:09.132Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2018/08/19/hello-world/"/>
    <id>http://yoursite.com/2018/08/19/hello-world/</id>
    <published>2018-08-18T16:35:54.063Z</published>
    <updated>2018-08-18T17:08:09.132Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h1 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h1><h1 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>okhttp源码解析</title>
    <link href="http://yoursite.com/2018/04/29/okhttp%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2018/04/29/okhttp源码解析/</id>
    <published>2018-04-29T02:41:03.000Z</published>
    <updated>2018-08-19T05:41:23.864Z</updated>
    
    <content type="html"><![CDATA[<p>安卓开发领域上<a href="https://github.com/square/okhttp" target="_blank" rel="noopener">Okhttp</a>、<a href="https://github.com/square/retrofit" target="_blank" rel="noopener">Retrofit</a>、<a href="https://github.com/ReactiveX/RxJava" target="_blank" rel="noopener">RxJava</a>无疑已经成为了开发过程中的三板斧。在安卓6.0中谷歌删除了HttpClient的相关代码，并且在系统层面上使用了OkHttp，因此足以说明了这个框架的优秀。</p><blockquote><p><a href="https://github.com/android-cn/android-open-project-analysis" target="_blank" rel="noopener">我们不重复造轮子不表示我们不需要知道轮子该怎么造及如何更好的造!</a> </p></blockquote><p>用了OkHttp已经一年多之后，现在是时候来一探究竟了!!</p><h1 id="整体思路"><a href="#整体思路" class="headerlink" title="整体思路"></a>整体思路</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;安卓开发领域上&lt;a href=&quot;https://github.com/square/okhttp&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Okhttp&lt;/a&gt;、&lt;a href=&quot;https://github.com/square/retrofit&quot; 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>记录-DockerCE安装</title>
    <link href="http://yoursite.com/2017/09/06/%E8%AE%B0%E5%BD%95-DockerCE%E5%AE%89%E8%A3%85/"/>
    <id>http://yoursite.com/2017/09/06/记录-DockerCE安装/</id>
    <published>2017-09-06T01:52:58.000Z</published>
    <updated>2017-09-06T01:55:44.126Z</updated>
    
    <content type="html"><![CDATA[<p><center><img src="https://i.imgur.com/6MKfO7k.jpg" alt=""></center></p><blockquote><p>配置如下:<br>Ubuntu 16.04LTS(64位版本)</p><p>本文的大部分步骤来自于docker的官方文档<br><a href="https://docs.docker.com/engine/installation/linux/docker-ce/ubuntu/" target="_blank" rel="noopener">https://docs.docker.com/engine/installation/linux/docker-ce/ubuntu/</a></p><p><strong>Docker是一种容器化的一种技术</strong></p></blockquote><p>由于docker目前分为了两个版本一个是商业版，一个是社区版，因此这里我们选择的是社区版也就是CE版本。</p><h5 id="Docker是一种类似虚拟机的一种技术，但是比虚拟机要轻量的多。"><a href="#Docker是一种类似虚拟机的一种技术，但是比虚拟机要轻量的多。" class="headerlink" title="Docker是一种类似虚拟机的一种技术，但是比虚拟机要轻量的多。"></a>Docker是一种类似虚拟机的一种技术，但是比虚拟机要轻量的多。</h5><h4 id="1-docker-ce安装的运行环境"><a href="#1-docker-ce安装的运行环境" class="headerlink" title="1.docker ce安装的运行环境"></a>1.docker ce安装的运行环境</h4><p>DockerCE的安装版本的要求</p><ul><li>Zesty 17.04</li><li>Xenial 16.04 (LTS)</li><li>Trusty 14.04 (LTS)</li></ul><p>如果你的系统是14.04版本则需要安装linux-image-extra-*，因为docker需要这两个包。</p><pre><code>sudo apt-get updatesudo apt-get install \linux-image-extra-$(uname -r) \linux-image-extra-virtual</code></pre><h4 id="2-删除之前版本的docker"><a href="#2-删除之前版本的docker" class="headerlink" title="2.删除之前版本的docker"></a>2.删除之前版本的docker</h4><p>之前版本的docker叫做docker或者docker-engine，如果之前安装过，卸载它们</p><pre><code>sudo apt-get remove docker docker-engine docker.io</code></pre><p>现在我们安装的docker的包名叫做<strong>docker-ce</strong></p><h4 id="3-安装docker-ce"><a href="#3-安装docker-ce" class="headerlink" title="3.安装docker-ce"></a>3.安装docker-ce</h4><p>1.更新包的索引</p><pre><code>sudo apt-get update</code></pre><p>2.安装允许让apt允许的ssl仓库的包(ps:\代表这句脚本没有写完，进行换行)</p><pre><code>sudo apt-get install \apt-transport-https \ca-certificates \curl \software-properties-common</code></pre><p>3.添加Docker GPG Key</p><pre><code>curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</code></pre><p>4.设置仓库地址,这里设置的x86的仓库地址</p><pre><code>sudo add-apt-repository \   &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \   $(lsb_release -cs) \   stable&quot;</code></pre><p>5.安装<br>ubuntu14.04以上的版本都是自带docker安装包的,所以可以直接安装,但是这个一般不是最新版本,所以一般需要进行更新源</p><pre><code>sudo apt-get updatesudo apt-get install docker.io</code></pre><p>2.安装完成了之后可以通过以下命令进行查看安装版本<br>    docker -v</p><p>3.下载docker的镜像</p><pre><code>docker run ubuntu:15.10 /bin/echo &quot;Hello world&quot;</code></pre><h5 id="重点来了！！镜像地址默认是国外的dockerhub，国内速度较慢，因此需要一个国内镜像去加速，这里使用的是的DaoCloud"><a href="#重点来了！！镜像地址默认是国外的dockerhub，国内速度较慢，因此需要一个国内镜像去加速，这里使用的是的DaoCloud" class="headerlink" title="重点来了！！镜像地址默认是国外的dockerhub，国内速度较慢，因此需要一个国内镜像去加速，这里使用的是的DaoCloud"></a>重点来了！！镜像地址默认是国外的dockerhub，国内速度较慢，因此需要一个国内镜像去加速，这里使用的是的DaoCloud</h5><p>如果本地没有ubuntu 15.10的镜像，那么docker会去从仓库中下载，但是下载的速度很慢。因此这里使用了Docker镜像的加速器</p><p><a href="https://www.daocloud.io/mirror#accelerator-doc" target="_blank" rel="noopener">https://www.daocloud.io/mirror#accelerator-doc</a></p><p>通过下面的命令即可完成配置加速器。</p><pre><code>curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://d606b909.m.daocloud.io</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;center&gt;&lt;img src=&quot;https://i.imgur.com/6MKfO7k.jpg&quot; alt=&quot;&quot;&gt;&lt;/center&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;配置如下:&lt;br&gt;Ubuntu 16.04LTS(64位版本)&lt;/p&gt;
&lt;p&gt;本文的大部分步骤来自
      
    
    </summary>
    
    
      <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>炫酷ViewPager指示器效果</title>
    <link href="http://yoursite.com/2017/07/31/%E7%82%AB%E9%85%B7ViewPager%E6%8C%87%E7%A4%BA%E5%99%A8%E6%95%88%E6%9E%9C/"/>
    <id>http://yoursite.com/2017/07/31/炫酷ViewPager指示器效果/</id>
    <published>2017-07-31T10:12:34.000Z</published>
    <updated>2018-08-19T05:09:40.012Z</updated>
    
    <content type="html"><![CDATA[<h3 id="写在前面的话"><a href="#写在前面的话" class="headerlink" title="写在前面的话"></a>写在前面的话</h3><h5 id="本文的源起是在有一天在网上看到的一个挺不错的一个效果而产生的一个想法，正好因为这段时间公司闲了下来，因此想着练习一下中定义view。"><a href="#本文的源起是在有一天在网上看到的一个挺不错的一个效果而产生的一个想法，正好因为这段时间公司闲了下来，因此想着练习一下中定义view。" class="headerlink" title="本文的源起是在有一天在网上看到的一个挺不错的一个效果而产生的一个想法，正好因为这段时间公司闲了下来，因此想着练习一下中定义view。"></a>本文的源起是在有一天在网上看到的一个挺不错的一个效果而产生的一个想法，正好因为这段时间公司闲了下来，因此想着练习一下中定义view。</h5><h5 id="本文以尽可能通俗的语言，让大家理解整个的绘制过程，尽量不粘贴代码-因为我认为思路往往比代码更重要-。还有就是可能对数学无感的人和不太友好。"><a href="#本文以尽可能通俗的语言，让大家理解整个的绘制过程，尽量不粘贴代码-因为我认为思路往往比代码更重要-。还有就是可能对数学无感的人和不太友好。" class="headerlink" title="本文以尽可能通俗的语言，让大家理解整个的绘制过程，尽量不粘贴代码(因为我认为思路往往比代码更重要)。还有就是可能对数学无感的人和不太友好。"></a>本文以尽可能通俗的语言，让大家理解整个的绘制过程，尽量不粘贴代码(因为我认为思路往往比代码更重要)。还有就是可能对数学无感的人和不太友好。</h5><h2 id="一、这篇文章你将会学到什么"><a href="#一、这篇文章你将会学到什么" class="headerlink" title="一、这篇文章你将会学到什么?"></a>一、这篇文章你将会学到什么?</h2><blockquote><p>1.学到一些自定义绘制中的一些技巧。</p><p>2.学习Bezier的一些相关知识。</p><p>3.利用面向对象更好的去解决一些复杂的问题。</p></blockquote><h2 id="二、准备"><a href="#二、准备" class="headerlink" title="二、准备"></a>二、准备</h2><h3 id="2-1-UI效果展示"><a href="#2-1-UI效果展示" class="headerlink" title="2.1 UI效果展示"></a>2.1 UI效果展示</h3><h3 id="原始效果图"><a href="#原始效果图" class="headerlink" title="原始效果图:"></a>原始效果图:</h3><p><img src="http://i.imgur.com/ybV4NBB.gif" alt=""></p><h3 id="实际运行图"><a href="#实际运行图" class="headerlink" title="实际运行图:"></a>实际运行图:</h3><p><img src="http://i.imgur.com/FRwSDei.gif" alt=""></p><h3 id="2-2-思考"><a href="#2-2-思考" class="headerlink" title="2.2 思考"></a>2.2 思考</h3><blockquote><p>1.界面由 ViewPager + 自定义指示器</p><p>2.ViewPager的间隔效果.</p><p>3.小球能够和ViewPager联动不断变化</p></blockquote><h3 id="2-3-ViewPager效果实现"><a href="#2-3-ViewPager效果实现" class="headerlink" title="2.3 ViewPager效果实现"></a>2.3 ViewPager效果实现</h3><p>我们看到上面的是一个可以滑动的ViewPager，但是默认的ViewPager是一页只能显示一个Item的，因此经过多方查找，我找到了如下方法可以实现这个效果:</p><h5 id="2-3-1-ViewPager的布局"><a href="#2-3-1-ViewPager的布局" class="headerlink" title="2.3.1 ViewPager的布局"></a>2.3.1 ViewPager的布局</h5><pre><code>&lt;android.support.v4.view.ViewPager    android:layout_above=&quot;@+id/bezierIndicator&quot;    android:id=&quot;@+id/viewPager&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    android:layout_centerVertical=&quot;true&quot;    android:layout_gravity=&quot;bottom&quot;    android:clipToPadding=&quot;false&quot;    android:overScrollMode=&quot;never&quot;    android:paddingBottom=&quot;10dp&quot;    android:paddingEnd=&quot;@dimen/card_padding&quot;    android:paddingLeft=&quot;@dimen/card_padding&quot;    android:paddingRight=&quot;@dimen/card_padding&quot;    android:paddingStart=&quot;@dimen/card_padding&quot;/&gt;</code></pre><h5 id="android-clipToPadding-”false”"><a href="#android-clipToPadding-”false”" class="headerlink" title="android:clipToPadding=”false”"></a>android:clipToPadding=”false”</h5><p>就是说控件的绘制区域是否在padding里面的，true的情况下绘制的区域不包括了Padding占据的那部分<br><img src="http://i.imgur.com/uxdywV1.png" alt=""><br>蓝线的部分即为我们绘制的区域，因为设置了true，而且默认是true，而我们想要把绘制区域在padding中那么就要将这个属性设置为false了。</p><h5 id="android-overScrollMode-”never”"><a href="#android-overScrollMode-”never”" class="headerlink" title="android:overScrollMode=”never”"></a>android:overScrollMode=”never”</h5><p>我们滑动的时候经常可以看到谷歌很多滑动的原生控件上都具有一个明显的特征(5.0以上)<br><img src="http://i.imgur.com/DewB1bC.png" alt=""></p><p>有一个阴影对吧，这个效果默认是有的，这个效果的含义就是滑动的时候可以滑出区域外，有一个简单的回弹效果，如果不想要这个阴影，也就是这个回弹，那么可以将这个属性设置成never即可。</p><p>再来就是设置padding值。但是还有没结束。</p><h5 id="2-3-2-ViewPager的代码设置"><a href="#2-3-2-ViewPager的代码设置" class="headerlink" title="2.3.2 ViewPager的代码设置"></a>2.3.2 ViewPager的代码设置</h5><pre><code>mViewPager = (ViewPager) findViewById(R.id.viewPager);mViewPager.setOffscreenPageLimit(3);mViewPager.setPageMargin(60);</code></pre><p>1.设置viewpager缓存页数，因为默认ViewPager只加载一页，因此这里设置成三个，让其全部加载。<br>2.设置setPageMargin是为了控制每一页Page之间的大小。产生一个间隔的效果。这里和padding的不同在于Padding是设置了边界，也就是第一页左边的那个大小，因此这里是设置每一页之间的大小的。</p><p>经过了上面的配置，我们的ViewPager就可以完成了下面所示的效果<br><img src="http://i.imgur.com/TDZ8ZEf.png" alt=""></p><h3 id="2-4-BezierIndicator"><a href="#2-4-BezierIndicator" class="headerlink" title="2.4 BezierIndicator"></a>2.4 BezierIndicator</h3><p>上面我们一步一步实现了ViewPager的效果，接下来的重头戏就是如何去实现小球？</p><p>细心的我们可以发现这个球一共经历了5个状态，并且动画是<em>通过形状的变化加上画布的位移而产生</em>的<br><img src="http://i.imgur.com/rHwii48.png" alt=""><br><img src="http://i.imgur.com/987EBUH.gif" alt=""></p><p>下面我们来一步一步来进行Beizer的绘制工作</p><h4 id="2-4-1-预热一下"><a href="#2-4-1-预热一下" class="headerlink" title="2.4.1 预热一下"></a>2.4.1 预热一下</h4><p>在开始画之前我们先来看一下这个Beizer的相关api，关于Bezier的数学原理在这里不会详细阐述(网络上有大量的说明，如果有兴趣可以自行查阅)。</p><p>在具体的讲解之前，我们来看看如果利用Bezier画圆。</p><p>下面这个图利用了PS中的钢笔工具进行了绘制，也就是说这个圆是由4条Bezier曲线组成的。<br><img src="http://i.imgur.com/dMXbG4Q.png" alt=""></p><p>利用如下代码即可完成绘制<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mPath.cubicTo(x1,y1,x2,y2,x3,y3);//x1,x2都是控制点,x3是终点</span><br></pre></td></tr></table></figure></p><p><img src="http://i.imgur.com/i4jslVi.png" alt=""></p><p>P1 P2 P3 P4分别是圆上的4个端点,它们连线的圆点即为该点的控制点。M为控制点到圆点的距离,那么M值的大小直接影响了曲线变化！</p><p>代码如下:</p><pre><code>mPath.reset();mPath.reset();mPath.moveTo(p1.x, p1.y);mPath.cubicTo(p1.rightX, p1.rightY, p2.bottomX, p2.bottomY, p2.x, p2.y);mPath.cubicTo(p2.topX, p2.topY, p3.rightX, p3.rightY, p3.x, p3.y);mPath.cubicTo(p3.leftX, p3.leftY, p4.topX, p4.topY, p4.x, p4.y);mPath.cubicTo(p4.bottomX, p4.bottomY, p1.leftX, p1.leftY, p1.x, p1.y);</code></pre><p>代码中，先将Path移动到p1点</p><pre><code>mPath.moveTo(p1.x, p1.y)</code></pre><p>然后利用p1右边的控制点,p2下方的控制点，以及p2点的坐标即可画出p1到p2的曲线</p><pre><code>mPath.cubicTo(p1.rightX, p1.rightY, p2.bottomX, p2.bottomY, p2.x, p2.y);</code></pre><p>其他的跟上面的写法是一样的，就不再赘述。</p><p>p1,p3的控制点由于是在水平方向上的，于是控制点的计算使用了如下的代码:</p><pre><code>this.x = x;this.y = y;this.m = m;leftX = x - m;rightX = x + m;leftY = y;rightY = y;</code></pre><p>根据资料查询的结果: M =  <em>0.5522847498</em>时，曲线的绘制就是一个圆弧。</p><blockquote><p><a href="http://spencermortensen.com/articles/bezier-circle/" target="_blank" rel="noopener">http://spencermortensen.com/articles/bezier-circle/</a>有一篇文章专门讲解了M点计算的原理。</p></blockquote><h2 id="三、开始"><a href="#三、开始" class="headerlink" title="三、开始"></a>三、开始</h2><h4 id="3-1来面向对象一下"><a href="#3-1来面向对象一下" class="headerlink" title="3.1来面向对象一下"></a>3.1来面向对象一下</h4><p><img src="http://i.imgur.com/JpN6uGa.png" alt=""></p><p>首先将小球进行了抽象，抽取成一个单独的类<em>BerizerCircle</em>，然后画出小球的时候需要一些控制点的坐标。在这里我们分为了水平端点(<em>HorizontalPoint</em>)和垂直端点坐标(<em>VerticalPoint</em>)。</p><p>那么问题来了什么是水平端点和垂直端点呢？哈哈哈，其实这里我只是自己这么称呼的而已，不要介意。</p><p>水平端点即为在水平方向上具有控制点的点，对应了我们刚才图上所示的P1,P3的两个端点，那么垂直端点也就是P2、P4了</p><p>下面来看一下其中的<strong>HorizontalPoint.java</strong>的构造函数</p><pre><code>public HorizontalPoint(float x, float y, float m) {    this.x = x;    this.y = y;    this.m = m;    leftX = x - m;    rightX = x + m;    leftY = y;    rightY = y;}</code></pre><p>这个构造函数的意思就是，通过设置端点的坐标(x,y)，以及端点到控制点的距离(M)，即可得到端点坐标和两个控制点的坐标。那么VerticalPoint类的构造函数的思路也就不用多说了。</p><p>那么构造端点方法可以通过如下的方式进行了</p><pre><code>p1 = new HorizontalPoint(0, R, M);p2 = new VerticalPoint(R, 0, M);p3 = new HorizontalPoint(0, -R, M);p4 = new VerticalPoint(-R, 0, M);</code></pre><p>如果上述不是看的很懂那么再一个图来理解一下<br><img src="http://i.imgur.com/XgOAb5N.png" alt=""></p><p>那么利用R,M我们可以把图中所有的端点和控制点进行了计算。</p><h4 id="3-2绘制流程"><a href="#3-2绘制流程" class="headerlink" title="3.2绘制流程"></a>3.2绘制流程</h4><p>下面我们来看一下<em>BezierCircle</em>下面这个核心的函数，思路就是通过滑动的百分比，来控制图形的形态。</p><pre><code>/** * 通过ViewPager的百分比进行控制显示的状态 * * @param fromPos * @param toPos * @param positionOffset Value from [0, 1) indicating the offset from the page at position. * @see android.support.v4.view.ViewPager.OnPageChangeListener */public void drawByPositionOffset(int fromPos, int toPos, float positionOffset) {    boolean isTurnRight = toPos - fromPos &gt; 0;    if (positionOffset &gt;= 0 &amp;&amp; positionOffset &lt;= 0.2f) {        buildCircle1(positionOffset, isTurnRight);    } else if (positionOffset &lt;= 0.5f) {        buildCircle2(positionOffset, isTurnRight);    } else if (positionOffset &lt;= 0.8f) {        buildCircle3(positionOffset, isTurnRight);    } else if (positionOffset &lt;= 0.9f) {        buildCircle4(positionOffset, isTurnRight);    } else if (positionOffset &lt;= 1.0f) {        buildCircle5(positionOffset, isTurnRight);    }}</code></pre><p><img src="http://i.imgur.com/Q0YEXmf.png" alt=""></p><p>上图就是一个小球变化的一个趋势图，整体的一个绘制思路和流程在上图可以进行了完整的体现。</p><p>那么下面我们来具体分析一下，小球在各个滑动区间中具体是如何变化的吧！</p><p><strong>3.2.1平移距离在(0,0.2]的范围内时</strong></p><p><img src="http://i.imgur.com/ohP8VAU.gif" alt=""></p><p>p2点在这个状态的中从(R,0)变成了(9/5 *R,0),<strong>positionOffset / 0.2f为这个区间(0,0.2]的变化率</strong>。</p><blockquote><p>x = R + 4 / 5.0f <em> R </em> P,P是变化率也就是positionOffset / 0.2f</p></blockquote><p>下面是代码：</p><pre><code>/** * 因为变化率是0 - 0.2f区间进行变化, 而p2点的x坐标则是从R - 4/5R之间进行变化, * 因此x = R + (4/5R * (变化率的百分比)) * 变化率的百分比为 pos / 0.2f   0.2为区间值,pos在0 - 0.2f之间变化 * * @param positionOffset */private void buildCircle1(float positionOffset) {   //0 &lt; pos &lt;=0.2f    p1.setX(0);    p3.setX(0);    p4.setX(-R);    p2.setX(R + 4 / 5.0f * R * positionOffset / 0.2f);}</code></pre><p>如果对上面的公式或者注释你还是无法有一个直观的理解，可以结合下面的图来进行进一步的加深<br><img src="http://i.imgur.com/GdUdPvK.png" alt=""></p><p>在buildCircle1中我们做的就是将P2点的坐标不断进行水平移动，从而让小球从状态1变化到了状态2了。</p><p><strong>3.2.2平移距离在(0.2,0.5]的范围内时</strong></p><p><img src="http://i.imgur.com/mqA6dSV.gif" alt=""></p><p>在这个过程中我们需要将小球进行变化成一个椭圆<br>通过下图我们可以看到如果单纯将P2点垂直方向上的控制点的距离进行增大，图形的右边就更加的椭圆了，因为要对称，所以同时改变P2点和p4的垂直方向上M的距离，就可以让这两边的曲线更加接近椭圆。<br><img src="http://i.imgur.com/REGqLHG.png" alt=""></p><p>但是还有一个问题，图形目前是不对称的，在上一个状态中我们移动了p2点的坐标R-&gt;9/5R，因此要让P2和p4对称，因此p1和p3也要同时进行移动，让其两点的x轴的坐标移动到新的中心点坐标。</p><p><strong>新的中心点在哪里？</strong></p><p>我们重新来看下坐标<br>P1(0,R)，P2(5/9R,0),P3(0，-R),P4（-R,0）<br>新的中心点的x轴的坐标为</p><blockquote><p>x = (p4.x + (p2.x - p4.x) / 2) * P</p></blockquote><p>我们可以看到公式中有一个除2的操作，为什么要除2呢?<br><img src="http://i.imgur.com/Q6tTjLZ.png" alt=""></p><p><strong>可以看到正方形，通过将右边的左边的点进行平移1个单位后</strong>,中心点从(0,0)变化至(0.5,0)。通过这个公式p4.x + (p2.x - p4.x) / 2,这里我们将p2.x = 2，p4.x = -1，通过计算得出了0.5，因此这就是为什么要这么写的原因了。</p><p>下面是代码：</p><pre><code>/** * 在这个过程中需要将Circle变成一个椭圆 * 这个里p2点的x是R + 4 / 5R,因此椭圆的长轴的距离为 R+ R + 4 / 5R = 14 / 5R * &lt;p&gt; * 然后 14 / 5R /2 为长轴一半 - R即为椭圆中心点的坐标 * * @param positionOffset */private void buildCircle2(float positionOffset) {   //0.2 &lt; pos &lt;= 0.5f    p2.setX(R + 4 / 5.f * R);    float x = ((R + R + 4 / 5.f * R) / 2.f - R) * (positionOffset - 0.2f) / 0.3f;    p1.setX(x);    p3.setX(x);    float m = M + M * 2 / 3.f * (positionOffset - 0.2f) / 0.3f;    p4.setM(m);    p2.setM(m);}</code></pre><p><strong>3.2.3平移距离在(0.5,0.8]的范围内时</strong></p><p><img src="http://i.imgur.com/3GKt8Rv.gif" alt=""></p><p>在这个过程中我们需要将椭圆变成如我们状态2那样子的有一头比较尖的圆形。</p><p>p2.x从9/5R 变化至 R</p><p>p4.x从-R 变化至 -9/5R</p><p>p1.x从((R +  9/5R) / 2.f - R)/2 变化至 0</p><p>p3.x从((R +  9/5R) / 2.f - R)/2 变化至 0</p><pre><code>/** * 在这个过程中需要将circle从一个椭圆变成左边较尖锐的椭圆 * * @param positionOffset */private void buildCircle3(float positionOffset) {       //0.5 - 0.8f    float x = ((R + R + 4 / 5.f * R) / 2.f - R) - ((R + R + 4 / 5.f * R) / 2.f - R) * (positionOffset - 0.5f) / 0.3f;    p1.setX(x);    p3.setX(x);    float m = 5.f * M / 3 - 2.f * M / 3 * (positionOffset - 0.5f) / 0.3f;    p2.setM(m);    p4.setM(m);    float p4X = -R - 4 / 5.f * R * (positionOffset - 0.5f) / 0.3f;    p4.setX(p4X);    float p2X = 9 / 5.f * R - 4 / 5.f * R * (positionOffset - 0.5f) / 0.3f;    p2.setX(p2X);}</code></pre><p><strong>3.2.4恢复成圆形(0.8,0.9]</strong></p><p><img src="http://i.imgur.com/AZFm3Sd.gif" alt=""></p><p>p4.x 从-9/5R 变化至 -R。并且重置一下p1、p2、p3的坐标</p><pre><code>private void buildCircle4(float positionOffset) {       //0.8 - 1.0    float p4X = -9 / 5.f * R + 4 / 5.f * R * (positionOffset - 0.8f) / 0.2f;    p4.setX(p4X);    p1.setX(0);    p3.setX(0);    p2.setX(R);}</code></pre><p><strong>3.2.5让小球进行回弹起来吧[0.9,1.0]</strong></p><p><img src="http://i.imgur.com/kwXQmEN.gif" alt=""></p><pre><code>double value = Math.sin(Math.toRadians((positionOffset - 0.9f) / 0.1f * 180));p4.setX((float) (-R +  R / 2.0f * value));</code></pre><p>为社么这里使用了sin函数呢?<br><img src="http://i.imgur.com/L0qETmy.jpg" alt=""></p><p><strong>在sin函数中x在[0，π/2]y轴的变化过程是[0,1]，x在[π/2，π]之间y轴的变化过程是[1,0]，这个y轴的变化过程正好满足我们这里回弹过程的变化率！！！因此使用sin作为这里控制回弹效果的产生是再合适不过的了。</strong></p><p><strong>3.2.6让小球进行平移</strong></p><p>前面我们都是通过改变p1,p2,p3,p4的坐标来改变小球的形状，然而还要进行添加位移，这样才能形成一个完整的动画，我在这里有两个思路</p><p>1.通过drawPath方法，不断地改变小球的x,y的位置来进行，然而这个的代价就是所有的坐标点都需要进行变化加上平移距离，得出最后的点的坐标</p><p>2.通过Canvas的translate方法，移动画布来达到我们这里平移动画的产生效果，显然，这一种方法我们不需要进行坐标转变即可完成动画效果，因为本控件也是采用了这一种方案。</p><p><img src="http://i.imgur.com/cOCWL6Q.png" alt=""></p><pre><code>canvas.save();canvas.translate(mStartPoint.x        + translateMoveSize * mPercent        + (span + 2 * R) * mViewPagerPosition, mStartPoint.y);Path path = mBezierCircle.buildPath();mPaint.setColor(color);canvas.drawPath(path, mPaint);canvas.restore();</code></pre><p>mStartPoint.x是计算的小球的起始位置。</p><pre><code>mStartPoint = new Point(span + R, h / 2);</code></pre><p>translateMoveSize是小球移动的一个单位的距离，mPercent是移动的百分比，mViewPagerPosition当前Page的位置。mStartPoint.x 先让小球平移到初始位置,然后加上 (span + 2 <em> R) </em> mViewPagerPosition当前页滑动页的距离，然后加上滑动的百分比在滑动距离上的比值，计算出最后的平移距离。</p><p>span的计算是通过下面的公式进行等分的计算出来的距离。</p><pre><code>span = (getWidth() - (count * R * 2)) / (count + 1);</code></pre><p><strong>3.2.7绑定ViewPager进行联动</strong></p><p>监听ViewPager的滑动事件自然是通过addOnPageChanageListener进行滑动的监听。在这里我们使用了如下的方法：</p><pre><code>@Overridepublic void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) {    if (!isInitialise) return;    if (!isMoveByTouch) {        boolean right = position + positionOffset - mViewPagerPosition &gt; 0;        if (positionOffset != 0.0f) {            //位移未完成            startColor = roundColors[mViewPagerPosition];            endColor = roundColors[(mViewPagerPosition + (right ? 1 : -1)) % roundColors.length];            color = mBezierCircle.getCurrentColor(right ? positionOffset : 1 - positionOffset, startColor, endColor);        }        moveBezierCirclePercent(position, positionOffset);    }}</code></pre><p>在这里我们先来看一下ViewPager数值的变化规律:<br>这是从左向右滑动的时候,从第0页向第一页滑动position从0变化到1，positionOffset:0.0到0.999最后在完成翻页了之后变成了0.0.</p><p><img src="http://i.imgur.com/h5iaGTj.png" alt=""></p><p>这是从右向左滑动的时候</p><p><img src="http://i.imgur.com/p32wjpw.png" alt=""></p><pre><code>boolean right = position + positionOffset - mCurrentPosition &gt; 0;if (positionOffset != 0.0f) {    //位移未完成    startColor = roundColors[mCurrentPosition];    endColor = roundColors[mCurrentPosition + (right ? 1 : -1)];    color = mBezierCircle.getCurrentColor(right ? positionOffset : 1 - positionOffset, startColor, endColor);}moveBezierCirclePercent(position, positionOffset);</code></pre><p>这里是颜色的相关计算,mCurrentPosition是当前页的位置。</p><p>0到1页时,颜色值从a-b进行变化,变化率从0.0到0.9</p><p>1到0页时,颜色值从b-a进行变化,变化率从0.9到0.0,因此需要进行1 - positionOffset让其从0.0到0.9进行变化，才满足我们变化的颜色公式。</p><p>下面是颜色变化的计算函数</p><pre><code>public int getCurrentColor(float percent, int startColor, int endColor) {    f[0][0] = (startColor &amp; 0xff0000) &gt;&gt; 16;    f[0][1] = (startColor &amp; 0x00ff00) &gt;&gt; 8;    f[0][2] = (startColor &amp; 0x0000ff);    f[1][0] = (endColor &amp; 0xff0000) &gt;&gt; 16;    f[1][1] = (endColor &amp; 0x00ff00) &gt;&gt; 8;    f[1][2] = (endColor &amp; 0x0000ff);    for (int i = 0; i &lt; 3; i++) {        result[i] = (int) (f[0][i] + (f[1][i] - f[0][i]) * percent);    }    return Color.rgb(result[0], result[1], result[2]);}</code></pre><h3 id="3-3-点击产生的涟漪效果"><a href="#3-3-点击产生的涟漪效果" class="headerlink" title="3.3 点击产生的涟漪效果"></a>3.3 点击产生的涟漪效果</h3><p>实际的原理是通过属性动画进行改变画笔画圆的半径，然后通过设置画笔的粗细程度来完成这一效果的实现。</p><p>在onDraw方法画出点击的产生的圆</p><pre><code>private void drawTouchWave(Canvas canvas) {    if (mTouchPoint.isShow()) {        canvas.drawCircle(mTouchPoint.getCenterX(), mTouchPoint.getCenterY(), mTouchPoint.R, mTouchPoint.mPaint);    }}</code></pre><p>在onTouchEvent进行点击效果的触发</p><pre><code>private int getDistance(float x1, float y1, float x2, float y2) {    return (int) Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));}@Overridepublic boolean onTouchEvent(MotionEvent event) {    super.onTouchEvent(event);    switch (event.getActionMasked()) {        case MotionEvent.ACTION_DOWN:            for (int i = 0; i &lt; mBitmapRects.length; i++) {                int distance = getDistance(mBitmapRects[i].centerX(), mBitmapRects[i].centerY(), event.getX(), event.getY());                if (distance &lt;= R) {                    mTouchPoint.setCenterX((int) mBitmapRects[i].centerX());                    mTouchPoint.setCenterY((int) mBitmapRects[i].centerY());                    mTouchPoint.setShow(true);                    startWave();                    startMoveBezierCircleByTouch(mCurrentPosition, i);                    break;                }            }            break;    }    return true;}</code></pre><p>通过两点之间的距离公式，判断是否在点击的区域范围内，然后通过startWave()方法进行显示点击的涟漪效果，通过startMoveBezierCircleByTouch方法进行从当前位置，跳转的指定的位置的平移变换。</p><pre><code>/** * 开启点击的水波纹 */private void startWave() {    ValueAnimator valueAnimator = ValueAnimator.ofFloat(R, 4.0f / 3 * R);    valueAnimator.setDuration(400);    valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {        @Override        public void onAnimationUpdate(ValueAnimator animation) {            float value = (float) animation.getAnimatedValue();            float percent = (value - R) / (1.f / 3 * R);            mTouchPoint.setStrokeWidth(TouchPoint.STROKE_WIDTH * (1 - percent));            mTouchPoint.R = value;            invalidate();        }    });    valueAnimator.addListener(new AnimatorListenerAdapter() {        @Override        public void onAnimationEnd(Animator animation) {            mTouchPoint.setShow(false);            invalidate();        }    });    valueAnimator.start();}</code></pre><p>通过改变R的半径以及画笔的粗细程度，即可完成了这一效果的绘制过程</p><p><img src="http://i.imgur.com/nBVpmbw.gif" alt=""></p><h3 id="3-4-点击产生的位移"><a href="#3-4-点击产生的位移" class="headerlink" title="3.4 点击产生的位移"></a>3.4 点击产生的位移</h3><p>上面我们看到点击后通过属性动画完成涟漪效果的显示，<strong>同样我们可以利用属性动画，让其模拟viewPager的参数的变化过程，这样之前的ViewPager函数就可以进行调用就行了</strong>。</p><pre><code>private void startMoveBezierCircleByTouch(final int formPos, final int toPos) {    if (formPos == toPos) return;    final boolean isTurnRight = toPos - formPos &gt; 0;    translateMoveSize = Math.abs(toPos - formPos) * (span + 2 * R);    setDurationScroller();    //位移未完成    startColor = roundColors[formPos];    endColor = roundColors[toPos];    mViewPager.setCurrentItem(toPos);    ValueAnimator valueAnimator = ValueAnimator.ofInt(0, Math.abs(translateMoveSize));    valueAnimator.setDuration(600);    valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {        @Override        public void onAnimationUpdate(ValueAnimator animation) {            isMoveByTouch = true;            int value = (int) animation.getAnimatedValue();            float percent = Math.abs(value * 1.0f) / Math.abs((toPos - formPos) * (span + 2 * R));            color = mBezierCircle.getCurrentColor(percent, startColor, endColor);            if (percent &gt;= 1.0f) {                isMoveByTouch = false;                translateMoveSize = span + 2 * R;                mViewPagerPosition = toPos;                setOriginScroller();                moveBezierCirclePercent(toPos, 0.0f);            } else {                moveBezierCirclePercent(isTurnRight ? formPos : toPos, isTurnRight ? percent : 1 - percent);            }        }    });    valueAnimator.start();}</code></pre><p>因为ViewPager在0页到1页的过程中position是0，positionOffset是0-0.9直到当滑动完成后变成了0，1页到0页的过程中positionOffset是从0.9 - 0，position是0，因此这里就是模拟这样子的参数而编写代码。</p><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>现在看一下之前的问题，看看心里有没有数</p><pre><code>do{    1.ViewPager一页显示多个item？    2.如何进行绘制一个不断变化的小球？    3.如何让小球进行和ViewPager的进行绑定？    4.如何让小球不断的进行变化？    5.如何生成点击后的涟漪效果？}while(不懂);</code></pre><p><img src="http://i.imgur.com/dhsnvVB.png" alt=""></p><p>最后非常感谢<strong><em>陈宇明</em></strong>大佬的细心指导,文章的结构顺序、还有内容都一一进行指正和阅读，很多地方都是根据其建议进行修改的。</p><p>本篇的分析就到此为止了，后面我会抽时间不断的完善这个demo，如果你有好的建议，请加Bravh交流群和我一起交流/学习，我在等你哟~！</p><h3 id="本项目地址"><a href="#本项目地址" class="headerlink" title="本项目地址"></a>本项目地址</h3><blockquote><p><a href="https://github.com/keep2iron/BezierIndicator" target="_blank" rel="noopener">https://github.com/keep2iron/BezierIndicator</a></p></blockquote><h5 id="在编写代码的过程中也并不是一帆风顺的，再次感谢广大的博主和开源作者，Android社区的繁荣离不开你们辛勤的劳动。下面是参考的博客地址和项目地址"><a href="#在编写代码的过程中也并不是一帆风顺的，再次感谢广大的博主和开源作者，Android社区的繁荣离不开你们辛勤的劳动。下面是参考的博客地址和项目地址" class="headerlink" title="在编写代码的过程中也并不是一帆风顺的，再次感谢广大的博主和开源作者，Android社区的繁荣离不开你们辛勤的劳动。下面是参考的博客地址和项目地址"></a>在编写代码的过程中也并不是一帆风顺的，再次感谢广大的博主和开源作者，Android社区的繁荣离不开你们辛勤的劳动。下面是参考的博客地址和项目地址</h5><blockquote><p><a href="http://blog.csdn.net/zanelove/article/details/50337623" target="_blank" rel="noopener">http://blog.csdn.net/zanelove/article/details/50337623</a></p><p><a href="http://www.jianshu.com/p/791d3a791ec2" target="_blank" rel="noopener">http://www.jianshu.com/p/791d3a791ec2</a></p><p><a href="https://github.com/Ulez/DropIndicator" target="_blank" rel="noopener">https://github.com/Ulez/DropIndicator</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;写在前面的话&quot;&gt;&lt;a href=&quot;#写在前面的话&quot; class=&quot;headerlink&quot; title=&quot;写在前面的话&quot;&gt;&lt;/a&gt;写在前面的话&lt;/h3&gt;&lt;h5 id=&quot;本文的源起是在有一天在网上看到的一个挺不错的一个效果而产生的一个想法，正好因为这段时间公司闲了下来
      
    
    </summary>
    
    
      <category term="Simple Record" scheme="http://yoursite.com/tags/Simple-Record/"/>
    
  </entry>
  
  <entry>
    <title>编写一个编译时注入框架</title>
    <link href="http://yoursite.com/2017/05/28/%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E7%BC%96%E8%AF%91%E6%97%B6%E6%B3%A8%E5%85%A5%E6%A1%86%E6%9E%B6/"/>
    <id>http://yoursite.com/2017/05/28/编写一个编译时注入框架/</id>
    <published>2017-05-28T09:40:00.000Z</published>
    <updated>2017-05-28T15:02:44.663Z</updated>
    
    <content type="html"><![CDATA[<p>最近在折腾AnnotationProcessor，想着通过学习黄油刀来编写一个自己android编译时注入框架。<br>这个项目的地址是我的自己编写的一个AnnotationProcessor库</p><blockquote><p><strong><a href="https://github.com/keep2iron/Fast4Android-InjectView" target="_blank" rel="noopener">https://github.com/keep2iron/Fast4Android-InjectView</a></strong><br>如果觉得这篇文章有点用，请记得给个star哟</p></blockquote><p>学习的过程中发现了一些需要知道的api，在了解了这些api的情况下，那么我相信你可以对这个东西的掌握会更加的熟练和精通。</p><p>下面是我用到相关api，<strong>请在了解这些api的基础上阅读代码，这样可以事半功倍哟。</strong><br><strong>javax.annotation.processing</strong><br>这个包用来声明注释处理器并允许注释处理器与注释处理工具环境通信的工具。 <table><tr><th style="text-algin:center;">类名</th><th style="text-algin:center;">说明</th></tr><tr><td>interface ExecutableElement</td><td>表示某个类或接口的方法、构造方法或初始化程序（静态或实例）,包括注释类型元素.</td></tr><tr><td>interface PackageElement</td><td>表示一个包程序元素.</td></tr><tr><td>interface TypeElement </td><td>表示一个类或接口程序元素.</td></tr><tr><td>interface TypeParameterElement </td><td>表示一般类、接口、方法或构造方法元素的形式类型参数.</td></tr><tr><td>interface     VariableElement </td><td>表示一个字段、enum 常量、方法或构造方法参数、局部变量或异常参数.</td></tr></table></p><blockquote><p>其中还运用到了<a href="https://github.com/square/javapoet" target="_blank" rel="noopener">javapoet</a>的相关api，利用这个库的api进行生成java代码。</p></blockquote><blockquote><p>使用了@AutoService这个是google的一个类库<a href="https://github.com/google/auto" target="_blank" rel="noopener">Auto</a>用来进行生成META-INF信息,这样可以不用我们自己手动去配置了</p></blockquote><p><strong>编译时顺序图</strong>点击下图选中的gradle脚本即可生成文件</p><p><img src="http://i.imgur.com/QZyE8lR.png" alt=""></p><p><strong>在代码中调用bind方法的顺序图</strong></p><p><img src="http://i.imgur.com/6ELqej3.png" alt=""></p><p><strong>生成文件执行的顺序图</strong><br><img src="http://i.imgur.com/mZoLFXQ.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在折腾AnnotationProcessor，想着通过学习黄油刀来编写一个自己android编译时注入框架。&lt;br&gt;这个项目的地址是我的自己编写的一个AnnotationProcessor库&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;ht
      
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>记录AndroidProcess调试</title>
    <link href="http://yoursite.com/2017/05/26/%E8%AE%B0%E5%BD%95AndroidProcess%E8%B0%83%E8%AF%95/"/>
    <id>http://yoursite.com/2017/05/26/记录AndroidProcess调试/</id>
    <published>2017-05-26T07:48:42.000Z</published>
    <updated>2017-05-26T07:49:04.166Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>记录AndroidProcess调试步骤</p><p><strong>第一步</strong>在AnnoProcessor中设置断点</p><p><img src="http://i.imgur.com/gWBxFFT.png" alt=""></p><p><strong>第二步</strong>修改</p><p>gradle.properties</p><p><strong>第三步</strong>添加如下代码</p><p>第一行的作用是允许gradle开启守护进程</p><p>第二行代码是设置gradle连接的端口号.这里原先是设置为5005，但是由于报错，说端口号被占用，因此改为5010</p><p><code>org.gradle.daemon=true</code></p><p><code>org.gradle.jvmargs=-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5010</code></p><p><strong>第四步</strong>在上一步的基础上在as控制台运行如下命令：</p><p><code>gradle --daemon</code></p><p>你可能会有如下的报错：</p><p><img src="http://i.imgur.com/gMRzcuZ.png" alt=""></p><p><strong>少年莫慌，这是因为gradle没有在你的电脑中配置的缘故，因此可以将gradle改成gradlew！！！！！</strong></p><p>gradlew相当于是gradle的一个包装，相当于接口，因此实现类是由，.gradle文件夹中的gradle-wrapper.properties中的distributionUrl后面指定的gradle版本决定的<strong>（PS:在这里可以看到面向接口的好处了吧）</strong></p><p>运行完成之后，gradle就已经开启了守护进程，他会监听在我们刚刚配置的指定的端口号上</p><p><strong>第五步</strong>配置AndroidStudio</p><p><img src="http://i.imgur.com/lmCs3Wd.png" alt=""></p><p><img src="http://i.imgur.com/B1tGwYV.png" alt=""></p><p><img src="http://i.imgur.com/y0vgumU.png" alt=""></p><p><strong>然后点击ok就可以了</strong>然后界面上就有这个配置项了，下面开始运行它，点击那个小虫子的图标，debug模式运行</p><p><img src="http://i.imgur.com/RQNGkba.png" alt=""></p><p><img src="http://i.imgur.com/hmokmXh.png" alt=""></p><p><strong>第五步</strong>最后一步啦，在命令行执行如下命令，让其进行编译，因此我们</p><p><code>gradle clean assembleDebug</code></p><p>在运行的过程中</p><p><img src="http://i.imgur.com/jivxUeh.png" alt=""></p><p>这里可以看到我们的断点执行啦！！ok到此AnnotationProcessor的调试就到此结束了~！</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;记录AndroidProcess调试步骤&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一步&lt;/strong&gt;在AnnoProcessor中设置断点&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/gWBxFFT.png&quot; alt=&quot;&quot;&gt;
      
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>View Chapter1</title>
    <link href="http://yoursite.com/2017/03/13/View%20Chapter1/"/>
    <id>http://yoursite.com/2017/03/13/View Chapter1/</id>
    <published>2017-03-13T14:40:00.000Z</published>
    <updated>2017-03-13T14:43:42.000Z</updated>
    
    <content type="html"><![CDATA[<h5 id="widget-chapter-1"><a href="#widget-chapter-1" class="headerlink" title="widget chapter 1"></a>widget chapter 1</h5><h5 id="作为自定义控件的开篇，用一个简单的自定义控件来作为我们博客的一个引子。"><a href="#作为自定义控件的开篇，用一个简单的自定义控件来作为我们博客的一个引子。" class="headerlink" title="作为自定义控件的开篇，用一个简单的自定义控件来作为我们博客的一个引子。"></a>作为自定义控件的开篇，用一个简单的自定义控件来作为我们博客的一个引子。</h5><h5 id="下面这个控件就是一个非常简单的进度条，这里我们愉快的命名为ProgressView。"><a href="#下面这个控件就是一个非常简单的进度条，这里我们愉快的命名为ProgressView。" class="headerlink" title="下面这个控件就是一个非常简单的进度条，这里我们愉快的命名为ProgressView。"></a>下面这个控件就是一个非常简单的进度条，这里我们愉快的命名为ProgressView。</h5><p>​    <img src="http://ojg4zrjfe.bkt.clouddn.com/pic1.png" alt="pic1"></p><blockquote><h6 id="1-extends-View-or-ViewGroup"><a href="#1-extends-View-or-ViewGroup" class="headerlink" title="1.extends View or ViewGroup"></a>1.extends View or ViewGroup</h6><h6 id="2-重写构造方法。"><a href="#2-重写构造方法。" class="headerlink" title="2.重写构造方法。"></a>2.重写构造方法。</h6><h6 id="重写的时候系统会提示重写构造方法，而这里我们基本上重写了三种构造方法。"><a href="#重写的时候系统会提示重写构造方法，而这里我们基本上重写了三种构造方法。" class="headerlink" title="重写的时候系统会提示重写构造方法，而这里我们基本上重写了三种构造方法。"></a>重写的时候系统会提示重写构造方法，而这里我们基本上重写了三种构造方法。</h6><h6 id="在这里说下为什么要重写三个构造方法呢？"><a href="#在这里说下为什么要重写三个构造方法呢？" class="headerlink" title="在这里说下为什么要重写三个构造方法呢？"></a>在这里说下为什么要重写三个构造方法呢？</h6><h6 id="这里与我们生成自定义控件的方式有着密切的关系"><a href="#这里与我们生成自定义控件的方式有着密切的关系" class="headerlink" title="这里与我们生成自定义控件的方式有着密切的关系"></a>这里与我们生成自定义控件的方式有着密切的关系</h6><h6 id="———–生成方式"><a href="#———–生成方式" class="headerlink" title="———–生成方式"></a>———–生成方式</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment">//生成ProgressView的方式</span></span><br><span class="line">&gt;</span><br><span class="line">&gt; <span class="comment">//直接在代码中new出来，这里的生成方式在于生成的view控件没有LayoutParams，也就是他目前没有大小，没有父容器，只是直接new出来</span></span><br><span class="line">&gt; ProgressView view = <span class="keyword">new</span> ProgressView(ctx);</span><br><span class="line">&gt;</span><br><span class="line">&gt; <span class="comment">//使用布局文件生成。</span></span><br><span class="line">&gt; &lt;com.housework.newhuosework.widget.ProgressView</span><br><span class="line">&gt;   app:pv_default_color=<span class="string">"#eeeeee"</span></span><br><span class="line">&gt;   app:pv_color=<span class="string">"#ffa72a"</span></span><br><span class="line">&gt;   android:text=<span class="string">"123456"</span></span><br><span class="line">&gt;   android:layout_width=<span class="string">"50dp"</span></span><br><span class="line">&gt;   android:layout_height=<span class="string">"50dp"</span>/&gt;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><h6 id="———–构造方法"><a href="#———–构造方法" class="headerlink" title="———–构造方法"></a>———–构造方法</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;   <span class="function"><span class="keyword">public</span> <span class="title">ProgressView</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">&gt;     <span class="keyword">this</span>(context, <span class="keyword">null</span>);</span><br><span class="line">&gt;   &#125;</span><br><span class="line">&gt;</span><br><span class="line">&gt;   <span class="comment">//@Nullable是android扩展包的注解，标识这个变量是可以为null的</span></span><br><span class="line">&gt;   <span class="function"><span class="keyword">public</span> <span class="title">ProgressView</span><span class="params">(Context context, @Nullable AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">&gt;     <span class="keyword">this</span>(context, attrs, <span class="number">0</span>);</span><br><span class="line">&gt;   &#125;</span><br><span class="line">&gt;</span><br><span class="line">&gt;   <span class="function"><span class="keyword">public</span> <span class="title">ProgressView</span><span class="params">(Context context, @Nullable AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">&gt;   &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><h6 id="tip"><a href="#tip" class="headerlink" title="tip:"></a>tip:</h6><h6 id="在第一种new出来的生成方式的时候，会调用一个参数的构造方法。"><a href="#在第一种new出来的生成方式的时候，会调用一个参数的构造方法。" class="headerlink" title="在第一种new出来的生成方式的时候，会调用一个参数的构造方法。"></a>在第一种new出来的生成方式的时候，会调用一个参数的构造方法。</h6><h6 id="第二种使用xml声明的方式则会调用两个参数的构造方法。"><a href="#第二种使用xml声明的方式则会调用两个参数的构造方法。" class="headerlink" title="第二种使用xml声明的方式则会调用两个参数的构造方法。"></a>第二种使用xml声明的方式则会调用两个参数的构造方法。</h6><h6 id="第三个构造方法具有三个参数，第三个参数的意义在于在当前主题中包含了style资源的一个属性值，适用于对于当前view的一个默认style。需要特别指出的是三个参数的构造方法系统是不进行调用的，需要我们这里显式的进行调用，比如我们的Button通过调用，并传递了com-android-internal-R-attr-buttonStyle，而在4-4的主题文件是holo风格，然后定义了button的默认的几个属性"><a href="#第三个构造方法具有三个参数，第三个参数的意义在于在当前主题中包含了style资源的一个属性值，适用于对于当前view的一个默认style。需要特别指出的是三个参数的构造方法系统是不进行调用的，需要我们这里显式的进行调用，比如我们的Button通过调用，并传递了com-android-internal-R-attr-buttonStyle，而在4-4的主题文件是holo风格，然后定义了button的默认的几个属性" class="headerlink" title="第三个构造方法具有三个参数，第三个参数的意义在于在当前主题中包含了style资源的一个属性值，适用于对于当前view的一个默认style。需要特别指出的是三个参数的构造方法系统是不进行调用的，需要我们这里显式的进行调用，比如我们的Button通过调用，并传递了com.android.internal.R.attr.buttonStyle，而在4.4的主题文件是holo风格，然后定义了button的默认的几个属性"></a>第三个构造方法具有三个参数，第三个参数的意义在于在当前主题中包含了style资源的一个属性值，适用于对于当前view的一个默认style。<font color="red">需要特别指出的是三个参数的构造方法系统是不进行调用的，需要我们这里显式的进行调用，比如我们的Button通过调用，并传递了com.android.internal.R.attr.buttonStyle，而在4.4的主题文件是holo风格，然后定义了button的默认的几个属性</font></h6><h6 id="exp"><a href="#exp" class="headerlink" title="exp:"></a>exp:</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="title">Button</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">&gt;     <span class="keyword">this</span>(context, <span class="keyword">null</span>);</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br><span class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="title">Button</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">&gt;     <span class="keyword">this</span>(context, attrs, com.android.internal.R.attr.buttonStyle);</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br><span class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="title">Button</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyle)</span> </span>&#123;</span><br><span class="line">&gt;     <span class="keyword">super</span>(context, attrs, defStyle);</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br><span class="line">&gt; &lt;style name=<span class="string">"Theme.DeviceDefault"</span> parent=<span class="string">"Theme.Holo"</span> &gt;</span><br><span class="line">&gt;     ...</span><br><span class="line">&gt;     &lt;item name="buttonStyle"&gt;@android:style/Widget.DeviceDefault.Button&lt;/item&gt;</span><br><span class="line">&gt;     ....</span><br><span class="line">&gt; &lt;/style&gt;</span><br><span class="line">&gt;       </span><br><span class="line">&gt; &lt;style name=<span class="string">"Widget.DeviceDefault.Button"</span> parent=<span class="string">"Widget.Holo.Button"</span> &gt;</span><br><span class="line">&gt; &lt;/style&gt;</span><br><span class="line">&gt;       </span><br><span class="line">&gt; &lt;style name=<span class="string">"Widget.Holo.Button"</span> parent=<span class="string">"Widget.Button"</span>&gt;</span><br><span class="line">&gt; &lt;item name="android:background"&gt;@android:drawable/btn_default_holo_dark&lt;/item&gt;</span><br><span class="line">&gt;     &lt;item name="android:textAppearance"&gt;?android:attr/textAppearanceMedium&lt;/item&gt;</span><br><span class="line">&gt;     &lt;item name="android:textColor"&gt;@android:color/primary_text_holo_dark&lt;/item&gt;</span><br><span class="line">&gt;     &lt;item name="android:minHeight"&gt;48dip&lt;/item&gt;</span><br><span class="line">&gt;     &lt;item name="android:minWidth"&gt;64dip&lt;/item&gt;</span><br><span class="line">&gt; &lt;/style&gt;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><h6 id="以上基本上重写一个自定义view的构造函数的基本流程"><a href="#以上基本上重写一个自定义view的构造函数的基本流程" class="headerlink" title="以上基本上重写一个自定义view的构造函数的基本流程"></a>以上基本上重写一个自定义view的构造函数的基本流程</h6><h6 id="3-重写onMeasure和onLayout"><a href="#3-重写onMeasure和onLayout" class="headerlink" title="3.重写onMeasure和onLayout"></a>3.重写onMeasure和onLayout</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&gt;   <span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">&gt;     <span class="keyword">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">&gt; <span class="comment">//获取测量的宽度和高度</span></span><br><span class="line">&gt;     <span class="keyword">int</span> widthSize = getMeasureSize(widthMeasureSpec);</span><br><span class="line">&gt;     <span class="keyword">int</span> heightSize = getMeasureSize(heightMeasureSpec);</span><br><span class="line">&gt;</span><br><span class="line">&gt;     <span class="keyword">int</span> size = widthSize &gt; heightSize ? heightSize : widthSize;</span><br><span class="line">&gt;     <span class="comment">//必须调用这个方法，进行设置大小</span></span><br><span class="line">&gt;     setMeasuredDimension(size,size);</span><br><span class="line">&gt;   &#125;</span><br><span class="line">&gt;</span><br><span class="line">&gt;   <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getMeasureSize</span><span class="params">(<span class="keyword">int</span> measureSpec)</span> </span>&#123;</span><br><span class="line">&gt;     <span class="keyword">int</span> mode = MeasureSpec.getMode(measureSpec);</span><br><span class="line">&gt;     <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">&gt;</span><br><span class="line">&gt;     <span class="keyword">switch</span>(mode)&#123;</span><br><span class="line">&gt;       <span class="keyword">case</span> MeasureSpec.EXACTLY:</span><br><span class="line">&gt;       <span class="keyword">case</span> MeasureSpec.AT_MOST:</span><br><span class="line">&gt;         size = MeasureSpec.getSize(measureSpec);</span><br><span class="line">&gt;         <span class="keyword">break</span>;</span><br><span class="line">&gt;       <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</span><br><span class="line">&gt;         size = CommonUtil.dp2px(getContext(),<span class="number">50</span>);</span><br><span class="line">&gt;         <span class="keyword">break</span>;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;     <span class="keyword">return</span> size;</span><br><span class="line">&gt;   &#125;</span><br><span class="line">&gt; <span class="comment">//决定了我们自己的控件相对与父控件的位置</span></span><br><span class="line">&gt;   <span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</span><br><span class="line">&gt;     <span class="keyword">super</span>.onLayout(changed, left, top, right, bottom);</span><br><span class="line">&gt;   &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><h6 id="在这里引用郭霖大大博客的一句话。this-is-source-gt-blog"><a href="#在这里引用郭霖大大博客的一句话。this-is-source-gt-blog" class="headerlink" title="在这里引用郭霖大大博客的一句话。this is source =&gt; blog"></a>在这里引用郭霖大大博客的一句话。this is source =&gt; <a href="http://blog.csdn.net/guolin_blog/article/details/16330267" target="_blank" rel="noopener">blog</a></h6><h6 id="EXACTLY"><a href="#EXACTLY" class="headerlink" title="EXACTLY"></a>EXACTLY</h6><h6 id="表示父视图希望子视图的大小应该是由specSize的值来决定的，系统默认会按照这个规则来设置子视图的大小，开发人员当然也可以按照自己的意愿设置成任意的大小。"><a href="#表示父视图希望子视图的大小应该是由specSize的值来决定的，系统默认会按照这个规则来设置子视图的大小，开发人员当然也可以按照自己的意愿设置成任意的大小。" class="headerlink" title="表示父视图希望子视图的大小应该是由specSize的值来决定的，系统默认会按照这个规则来设置子视图的大小，开发人员当然也可以按照自己的意愿设置成任意的大小。"></a>表示父视图希望子视图的大小应该是由specSize的值来决定的，系统默认会按照这个规则来设置子视图的大小，开发人员当然也可以按照自己的意愿设置成任意的大小。</h6><h6 id="AT-MOST"><a href="#AT-MOST" class="headerlink" title="AT_MOST"></a>AT_MOST</h6><h6 id="表示子视图最多只能是specSize中指定的大小，开发人员应该尽可能小得去设置这个视图，并且保证不会超过specSize。系统默认会按照这个规则来设置子视图的大小，开发人员当然也可以按照自己的意愿设置成任意的大小。"><a href="#表示子视图最多只能是specSize中指定的大小，开发人员应该尽可能小得去设置这个视图，并且保证不会超过specSize。系统默认会按照这个规则来设置子视图的大小，开发人员当然也可以按照自己的意愿设置成任意的大小。" class="headerlink" title="表示子视图最多只能是specSize中指定的大小，开发人员应该尽可能小得去设置这个视图，并且保证不会超过specSize。系统默认会按照这个规则来设置子视图的大小，开发人员当然也可以按照自己的意愿设置成任意的大小。"></a>表示子视图最多只能是specSize中指定的大小，开发人员应该尽可能小得去设置这个视图，并且保证不会超过specSize。系统默认会按照这个规则来设置子视图的大小，开发人员当然也可以按照自己的意愿设置成任意的大小。</h6><h6 id="UNSPECIFIED"><a href="#UNSPECIFIED" class="headerlink" title="UNSPECIFIED"></a>UNSPECIFIED</h6><h6 id="表示开发人员可以将视图按照自己的意愿设置成任意的大小，没有任何限制。这种情况比较少见，不太会用到。"><a href="#表示开发人员可以将视图按照自己的意愿设置成任意的大小，没有任何限制。这种情况比较少见，不太会用到。" class="headerlink" title="表示开发人员可以将视图按照自己的意愿设置成任意的大小，没有任何限制。这种情况比较少见，不太会用到。"></a>表示开发人员可以将视图按照自己的意愿设置成任意的大小，没有任何限制。这种情况比较少见，不太会用到。</h6><h6 id="4-初始化控件的大小位置"><a href="#4-初始化控件的大小位置" class="headerlink" title="4.初始化控件的大小位置"></a>4.初始化控件的大小位置</h6><h6 id="一般我觉得写自定义控件来说，获取他的大小基本上必不可少，那么在什么函数获取大小比较合适呢？我个人认为在onSizeChanged-int-w-int-h-int-oldw-int-oldh-这个方法中进行赋值大小比较合适。"><a href="#一般我觉得写自定义控件来说，获取他的大小基本上必不可少，那么在什么函数获取大小比较合适呢？我个人认为在onSizeChanged-int-w-int-h-int-oldw-int-oldh-这个方法中进行赋值大小比较合适。" class="headerlink" title="一般我觉得写自定义控件来说，获取他的大小基本上必不可少，那么在什么函数获取大小比较合适呢？我个人认为在onSizeChanged(int w, int h, int oldw, int oldh) 这个方法中进行赋值大小比较合适。"></a>一般我觉得写自定义控件来说，获取他的大小基本上必不可少，那么在什么函数获取大小比较合适呢？我个人认为在onSizeChanged(int w, int h, int oldw, int oldh) 这个方法中进行赋值大小比较合适。</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;   <span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onSizeChanged</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">int</span> oldw, <span class="keyword">int</span> oldh)</span> </span>&#123;</span><br><span class="line">&gt;     <span class="keyword">super</span>.onSizeChanged(w, h, oldw, oldh);</span><br><span class="line">&gt; <span class="comment">//初始化画笔的宽度</span></span><br><span class="line">&gt;     <span class="keyword">int</span> strokeSize = (<span class="keyword">int</span>) (getMeasuredWidth() / <span class="number">2</span> * <span class="number">0.3f</span>);</span><br><span class="line">&gt;     <span class="keyword">int</span> size = <span class="number">10</span> + strokeSize;</span><br><span class="line">&gt;     <span class="comment">//初始化绘制区域</span></span><br><span class="line">&gt;     mDrawRect = <span class="keyword">new</span> RectF(getPaddingLeft() + size,getPaddingTop() + size,getWidth() - getPaddingLeft() - size,getHeight() - getPaddingBottom() - size);</span><br><span class="line">&gt;     mPaint.setStrokeWidth(strokeSize);</span><br><span class="line">&gt;   &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><h6 id="5-进行绘制view"><a href="#5-进行绘制view" class="headerlink" title="5.进行绘制view"></a>5.进行绘制view</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;   <span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">&gt;     <span class="comment">//保存画布的当前状态</span></span><br><span class="line">&gt;     canvas.save();</span><br><span class="line">&gt;     <span class="comment">//旋转画布逆时针90°，那么坐标系就发生了旋转了。</span></span><br><span class="line">&gt;     canvas.rotate(-<span class="number">90</span>,mDrawRect.centerX(),mDrawRect.centerY());</span><br><span class="line">&gt;     <span class="comment">//设置背景圆的颜色</span></span><br><span class="line">&gt;     mPaint.setColor(mDefColor);</span><br><span class="line">&gt;     canvas.drawCircle(mDrawRect.centerX(),mDrawRect.centerY(),mDrawRect.width() / <span class="number">2</span>,mPaint);</span><br><span class="line">&gt;     <span class="comment">//设置弧线的颜色</span></span><br><span class="line">&gt;     mPaint.setColor(mColor);</span><br><span class="line">&gt;     canvas.drawArc(mDrawRect,<span class="number">0</span>,mProgress * <span class="number">360</span>,<span class="keyword">false</span>,mPaint);</span><br><span class="line">&gt;     <span class="comment">//重新恢复画布</span></span><br><span class="line">&gt;     canvas.restore();</span><br><span class="line">&gt;   &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h5 id="最后面整个view的绘制就完成了。附上代码的链接。"><a href="#最后面整个view的绘制就完成了。附上代码的链接。" class="headerlink" title="最后面整个view的绘制就完成了。附上代码的链接。"></a>最后面整个view的绘制就完成了。附上代码的链接。</h5>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;widget-chapter-1&quot;&gt;&lt;a href=&quot;#widget-chapter-1&quot; class=&quot;headerlink&quot; title=&quot;widget chapter 1&quot;&gt;&lt;/a&gt;widget chapter 1&lt;/h5&gt;&lt;h5 id=&quot;作为自定义控件的开
      
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>git</title>
    <link href="http://yoursite.com/2017/01/09/git/"/>
    <id>http://yoursite.com/2017/01/09/git/</id>
    <published>2017-01-09T07:55:34.000Z</published>
    <updated>2017-05-26T07:42:25.502Z</updated>
    
    <content type="html"><![CDATA[<div style="text-align:center"><span style="text-weight:600;text-size:40px;">Read the fuck source code</span></div><h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><p><strong>git</strong>是什么东东，吼吼，我不会告诉你它就是地表最强的分布式管理系统。</p><p>很多人都知道，Linus在1991年创建了开源的Linux，从此，Linux系统不断发展，已经成为最大的服务器系统软件了。</p><p>Linus虽然创建了Linux，但Linux的壮大是靠全世界热心的志愿者参与的，这么多人在世界各地为Linux编写代码，那Linux的代码是如何管理的呢？</p><p>事实是，在2002年以前，世界各地的志愿者把源代码文件通过diff的方式发给Linus，然后由Linus本人通过手工方式合并代码！</p><p>你也许会想，为什么Linus不把Linux代码放到版本控制系统里呢？不是有CVS、SVN这些免费的版本控制系统吗？因为Linus坚定地反对CVS和SVN，这些集中式的版本控制系统不但速度慢，而且必须联网才能使用。有一些商用的版本控制系统，虽然比CVS、SVN好用，但那是付费的，和Linux的开源精神不符。</p><p>不过，到了2002年，Linux系统已经发展了十年了，代码库之大让Linus很难继续通过手工方式管理了，社区的弟兄们也对这种方式表达了强烈不满，于是Linus选择了一个商业的版本控制系统BitKeeper，BitKeeper的东家BitMover公司出于人道主义精神，授权Linux社区免费使用这个版本控制系统。</p><p>安定团结的大好局面在2005年就被打破了，原因是Linux社区牛人聚集，不免沾染了一些梁山好汉的江湖习气。开发Samba的Andrew试图破解BitKeeper的协议（这么干的其实也不只他一个），被BitMover公司发现了（监控工作做得不错！），于是BitMover公司怒了，要收回Linux社区的免费使用权。</p><p>Linus可以向BitMover公司道个歉，保证以后严格管教弟兄们，嗯，这是不可能的。实际情况是这样的：</p><p>Linus花了两周时间自己用C写了一个分布式版本控制系统，这就是Git！一个月之内，Linux系统的源码已经由Git管理了！牛是怎么定义的呢？大家可以体会一下。</p><p>Git迅速成为最流行的分布式版本控制系统，尤其是2008年，GitHub网站上线了，它为开源项目免费提供Git存储，无数开源项目开始迁移至GitHub，包括jQuery，PHP，Ruby等等。</p><p>历史就是这么偶然，如果不是当年BitMover公司威胁Linux社区，可能现在我们就没有免费而超级好用的Git了。</p><div style="text-align:right;">以上出自<a href="http://www.liaoxuefeng.com" target="_blank" rel="noopener">廖雪峰老师</a>的<strong>git</strong>博文</div><hr><p>下面让我们来进入git的世界，来领略一下这个最好的分布式系统的魅力。</p><p>跟着下面的步骤走，我相信肯定没有问题。（默认已经是安装了git，这里我相信大家应该都没有什么问题。）</p><blockquote><p>1.开启一个控制台，找一个文件夹，git init                        –第一步就是找到我们的一个工作目录来进行初始化</p></blockquote><blockquote><p>2.在文件夹下建立一个readme.txt,然后输入命令git add readme.txt        –这就是所谓的第二步，添加一个文件</p></blockquote><blockquote><p>3.在控制台中继续输入命令git commit -m “init commit”                –第三步就是对所添加的文件进行提交。</p></blockquote><p>好了，以上的过程就是一个基本的git 提交文件的流程，那么我想看到这里，屏幕外的你肯定会说，你这TMD在逗我呢！！！</p><p>哈哈哈，以上的步骤的只是在你的机器上提交了文件，可是git可是分布式的呀，那么应该需要一台服务器作为我们文件交换的一个枢纽吧，在这里如果你对github没有一点了解的话，那么就先去github注册一个账号再说吧！</p><hr><p>如果在这里你没有注册github账号，那么你将没有办法体验到git真正的强大之处了。</p><blockquote><p><strong>这里是作为重要的第一步。点击如下图所示的这个按钮，进入一个页面填写完成这个仓库的相关信息之后，创建仓库。</strong>(Ps:在这里我也是跟大家共同建立了一个我们git专属的练习仓库)</p><p><img src="http://ojg4zrjfe.bkt.clouddn.com/git_step1.png" alt="github step 1"></p><p><img src="http://ojg4zrjfe.bkt.clouddn.com/CreateRepository.png" alt="repositoryCreate"></p></blockquote><blockquote><p><strong>好了这时候我们就拥有了自己的专属的小空间啦！</strong></p></blockquote><p>通过下面的指令便可以进行提交操作啦</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="string">"# GitTest"</span> &gt;&gt; README.md<span class="comment">//创建ReadMe.MD文件</span></span><br><span class="line">git init</span><br><span class="line">git add README.md</span><br><span class="line">git commit -m <span class="string">"first commit"</span></span><br><span class="line">git remote add origin git@github.com:keep2iron/GitTest.git<span class="comment">//这里需要改成你自己的git仓库地址</span></span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;div style=&quot;text-align:center&quot;&gt;&lt;span style=&quot;text-weight:600;text-size:40px;&quot;&gt;Read the fuck source code&lt;/span&gt;&lt;/div&gt;

&lt;h1 id=&quot;Overview&quot;&gt;&lt;a hr
      
    
    </summary>
    
    
      <category term="Simple Record" scheme="http://yoursite.com/tags/Simple-Record/"/>
    
  </entry>
  
  <entry>
    <title>Lorem ipsum dolor</title>
    <link href="http://yoursite.com/2015/12/31/Lorem%20ipsum%20dolor/"/>
    <id>http://yoursite.com/2015/12/31/Lorem ipsum dolor/</id>
    <published>2015-12-31T06:49:13.000Z</published>
    <updated>2018-08-19T05:43:17.032Z</updated>
    
    <content type="html"><![CDATA[<p>Lorem ipsum dolor sit amet, consectetur adipisicing elit. Totam, non numquam saepe ex ut. Deleniti culpa inventore consectetur nam saepe!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit. Totam, non numquam saepe ex ut. Deleniti culpa inventore consectetur nam saepe!
      
    
    </summary>
    
    
  </entry>
  
</feed>
