<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 希尔排序 & 归并排序 · Keep2iron's Road to development</title><meta name="description" content="希尔排序 &amp; 归并排序 - Keep2iron"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://keep2iron.github.io/atom.xml" title="Keep2iron's Road to development"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/Keep2iron" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/keep2iron" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">希尔排序 & 归并排序</h1><div class="post-info">Mar 28, 2019</div><div class="post-content"><p><img src="https://i.imgur.com/I6WksMT.jpg" width="680px"></p>
<blockquote>
<p><a href="https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">维基百科-快速排序</a><br><a href="https://zh.wikipedia.org/wiki/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">维基百科-归并排序</a><br><a href="https://www.cnblogs.com/onepixel/articles/7674659.html" target="_blank" rel="noopener">cnblog-排序算法</a></p>
</blockquote>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><h4 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h4><p>希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。希尔排序是非稳定排序算法。</p>
<ul>
<li>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</li>
<li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率</li>
<li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位</li>
</ul>
<p><strong>步长</strong>的选择是希尔排序的重要部分。只要最终步长为1任何步长序列都可以工作。算法最开始以一定的步长进行排序。然后会继续以一定步长进行排序，最终算法以步长为1进行排序。当步长为1时，算法变为普通插入排序，这就保证了数据一定会被排序。</p>
<ul>
<li>取初始的步长为step(初始值为数组长度arr的一半)</li>
<li>以步长为单位 让arr[step] arr[step <em> 2] … arr[step </em> n]进行插入排序</li>
<li>步长进行除二直至步长单位为1时进行全数列的插入排序</li>
</ul>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public void shellSort(int[] arr)&#123;</span><br><span class="line">	int step = maxSize / 2;</span><br><span class="line">	while (step &gt;= 1) &#123;</span><br><span class="line">	    for (int i = step; i &lt; arr.length; i += step) &#123;</span><br><span class="line">	        int currentItem = arr[i];</span><br><span class="line">	        int preIndex = i - step;</span><br><span class="line">	        while (preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; currentItem) &#123;</span><br><span class="line">	            arr[preIndex + step] = arr[preIndex];</span><br><span class="line">	            preIndex -= step;</span><br><span class="line">	        &#125;</span><br><span class="line">	        if (preIndex + step != i) &#123;</span><br><span class="line">	            arr[preIndex + step] = currentItem;</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	    step /= 2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h4 id="算法描述-1"><a href="#算法描述-1" class="headerlink" title="算法描述"></a>算法描述</h4><p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 </p>
<p>递归方案</p>
<ul>
<li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列</li>
<li>设定两个指针，最初位置分别为两个已经排序序列的起始位置</li>
<li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置</li>
<li>重复步骤3直到某一指针到达序列尾</li>
<li>将另一序列剩下的所有元素直接复制到合并序列尾</li>
</ul>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public static void mergeSort(int[] arr) &#123;</span><br><span class="line">    int[] result = new int[arr.length];</span><br><span class="line"></span><br><span class="line">    mergeSortRecursive(arr, result, 0, arr.length - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void mergeSortRecursive(int[] arr, int[] result, int start, int end) &#123;</span><br><span class="line">    if (start &gt;= end) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int length = end - start;</span><br><span class="line">    int mid = start + (length &gt;&gt; 2);</span><br><span class="line"></span><br><span class="line">    int start1 = start;</span><br><span class="line">    int start2 = mid + 1;</span><br><span class="line">    int end1 = mid;</span><br><span class="line">    int end2 = end;</span><br><span class="line"></span><br><span class="line">    mergeSortRecursive(arr, result, start1, end1);</span><br><span class="line">    mergeSortRecursive(arr, result, start2, end2);</span><br><span class="line"></span><br><span class="line">    int k = start;</span><br><span class="line"></span><br><span class="line">    while (start1 &lt;= end1 &amp;&amp; start2 &lt;= end2) &#123;</span><br><span class="line">        result[k++] = arr[start1] &gt; arr[start2] ? arr[start2++] : arr[start1++];</span><br><span class="line">    &#125;</span><br><span class="line">    while (start1 &lt;= end1) &#123;</span><br><span class="line">        result[k++] = arr[start1++];</span><br><span class="line">    &#125;</span><br><span class="line">    while (start2 &lt;= end2) &#123;</span><br><span class="line">        result[k++] = arr[start2++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = start; i &lt;= end; i++) &#123;</span><br><span class="line">        arr[i] = result[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="动图演示"><a href="#动图演示" class="headerlink" title="动图演示"></a>动图演示</h4><p><img src="https://i.imgur.com/9MhBXsA.gif" width="640px"><br><a id="more"></a></p>
</div></article></div></main><footer><div class="paginator"><a href="/2019/03/28/快速排序/" class="prev">PREV</a><a href="/2019/03/28/选择排序&amp;插入排序/" class="next">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'keep2iron';
var disqus_identifier = '2019/03/28/希尔排序&amp;归并排序/';
var disqus_title = '希尔排序 &amp; 归并排序';
var disqus_url = 'https://keep2iron.github.io/2019/03/28/希尔排序&amp;归并排序/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//keep2iron.disqus.com/count.js" async></script><div class="copyright"><p>© 2015 - 2019 <a href="https://keep2iron.github.io">Keep2iron</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>